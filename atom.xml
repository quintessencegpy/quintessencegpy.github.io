<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CyberHex</title>
  
  <subtitle>Simple(r) Always Wins.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cyberhex.me/"/>
  <updated>2020-12-01T13:27:22.682Z</updated>
  <id>http://cyberhex.me/</id>
  
  <author>
    <name>Penstein</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CreateML - 开启革命的星星之火</title>
    <link href="http://cyberhex.me/2020/11/24/create-ml-introduction/"/>
    <id>http://cyberhex.me/2020/11/24/create-ml-introduction/</id>
    <published>2020-11-24T12:56:24.000Z</published>
    <updated>2020-12-01T13:27:22.682Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是苹果线上活动 - 基于 CreateML 的物体识别的观后感和一点想法。<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Core ML 在 2017 年的横空出世开启了 iOS 机器学习的元年。但苹果貌似并没有准备在这条路上停下脚步，隔了仅仅一年，苹果就推出了 Create ML，之后苹果还在不断地给 Core ML 和 Create ML 添加新的功能，甚至在 XCode 11 之后将 Create ML 独立成为一个单独的 App。由此可见，苹果并不是拍拍脑袋或者搞搞 KPI（他们应该没有，只是为了押韵），他们是认真在考虑把 Machine Learning 移植到移动端，并且不断地在尝试去降低 Machine Learning 的门槛，让越来越多的开发正更方便的使用 Machine Learning 给自己的应用增砖添瓦。</p><h2 id="什么是-Create-ML"><a href="#什么是-Create-ML" class="headerlink" title="什么是 Create ML"></a>什么是 Create ML</h2><p>关于 CreateML 网上有太多的介绍和教程，我只做一下简单的介绍，因为我再怎么努力也没办法比前人讲的更好更清楚，既然这样，那就站在巨人的肩膀上，大概讲一下我的认识。</p><p>苹果在 2016 年收购了 Turi Create，然后在此基础上发展出了 Create ML（虽然在 WWDC 中没有明说，但是大家都心知肚明）。在 Create ML 之前如果你想在 iOS 中使用 Core ML 的 Model（mlmodel 格式的文件）的话，只能在 TensorFlow，Pytorch 等流行的框架中先进行模型训练，然后通过 Core ML 中的 converter 把这些模型转换成 mlmodel 的格式。这其实是有一定门槛的，首先你得对 TensorFlow，Pytorch 有一定的了解，也要会使用 Python 语言（虽然不是很难），最重要的是你得对机器学习有比较多的了解，才能把自己的想法转化成模型。</p><p>但 Create ML 的出现，打破了这个壁垒。Create ML 中现在有很多机器学习的类型，包括：Image，Video，Motion，Sound，Text 和 Table，囊括了很多我们平时会遇到的场景，我们通过其中预设的 Template 再加上几行代码（如果你用 GUI 工具甚至一行代码都不用写），通过对收集的数据进行训练，在你的 Mac 上就可以得到一个 well-trained 模型。这其中除了一些对数据集有一些需要注意的点 - 比如数据集要尽量均衡，要有不同的背景、不同的角度，要有噪音等等，你不需要对内部的神经网络之类的有很多的了解。剩下需要你做的基本就是一些拖拽，设置参数，泡杯卡布奇诺等待 Mac 帮你 Training 之类的操作。</p><p>关于 Create ML 具体要怎么操作，你可以看 Raywenerlich 的这篇教程 <a href="https://www.raywenderlich.com/5653-create-ml-tutorial-getting-started#toc-anchor-020" target="_blank" rel="noopener">Create ML Tutorial: Getting Started</a>，或者如果你更喜欢看中文版，可以看故胤道长的这篇博客 <a href="http://www.cocoachina.com/articles/26420" target="_blank" rel="noopener">WWDC 2018：初探 Create ML</a>，都是非常好的参考资料，比我写的不知道高到哪里去了。</p><h2 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h2><p>Transfer Learning（迁移学习）就是把已学训练好的模型参数迁移到新的模型来帮助新模型训练。苹果在 Create ML 也用到了 Transfer Learning ，这样可以大幅缩短 Training 的时间，Model 的体积和数据量。当然你也可以选择 Full Network 的方式来进行，但是按照苹果的说法是 Full Network 和 Transfer Learning 可以达到几乎一致的结果，所以从成本的角度来考虑完全没有必要使用 Full Network 的方式（当时这是在完全相信苹果的前提下）。</p><p>Full Network 和 Transfer Training 的区别就是：Full Network 是从头开始训练一个模型，而 Transfer Training 形象的来说就是苹果给你一个半成品模型（Backbone），这个模型已经被苹果用大量的数据调教过了，然后你再用这个半成品进行二次训练，从而节省更多的成本。</p><h2 id="这次活动都讲了什么"><a href="#这次活动都讲了什么" class="headerlink" title="这次活动都讲了什么"></a>这次活动都讲了什么</h2><p>这次会议是关于物体识别的，这个主要是用了 Create ML 中 Image 类型下的 Object Detection Template。</p><p>更详细的记录可以看我同事温和的<a href="https://www.notion.so/Create-ML-84d28aa842064be7b74eb3bde136bd93" target="_blank" rel="noopener">笔记</a>。</p><h2 id="Create-ML-的优势"><a href="#Create-ML-的优势" class="headerlink" title="Create ML 的优势"></a>Create ML 的优势</h2><h3 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h3><p>在 Swift 中，新手能很快上手用 Swift 编写 iOS App，甚至他们都不需要了解泛型，函数式等比较高阶一点的用法；但对于有多年 Swift 经验的老同志来说，如果想用到更 Fancy 的功能，Swift 也能满足你的需求。Create ML 继承了苹果一贯的思想 - 对没有任何机器学习的新手来说非常友好，但同时对那些想“搞事情”的老玩家也提供了一些底层的 API 来进行一些他们想要的操作。</p><h3 id="高效率"><a href="#高效率" class="headerlink" title="高效率"></a>高效率</h3><p>由于 Transfer Learning 的原因，Training 所需要的时间数据集和都不多，这节省了很多等待和收集数据的时间。而且对于 iOS 开发者来说，都不需要新学一门语言就可以直接上手，这也节约了很多学习和开发成本。</p><h2 id="Create-ML-能为我们带来什么"><a href="#Create-ML-能为我们带来什么" class="headerlink" title="Create ML 能为我们带来什么"></a>Create ML 能为我们带来什么</h2><p>还记得在上研究生时为了训练马里奥让他轻松过关，训练了一晚上这货还是傻乎乎的往大乌龟上撞。虽然这大概率是我模型建的太渣，但也从一个侧面体现出来了一个问题，就是传统的 Training 太耗费时间了，不懂得“点到为止”。作为一个学生，这个带来的结果最多是错过 deadline，你跟教授死缠烂打一下，他说不定就睁一只眼闭一只眼过去了（我可没有这么做过啊）。但是放在生产中，这代价就不会只有错过 deadline 这么简单了，这会影响产品的上线和迭代，从而影响市场占有率。在产品的早期，产品的完成度比完美度更有说服力，所以选择 Create ML 这样的工具，以较低的成本先占领市场，然后再慢慢完善产品的迭代也是一种不错的选择。</p><p>同时，对于没有专门的 AI Team 的小企业或者是个人开发者，Create ML 也为他们提供了绝佳的武器。他们可以实现一些比较轻量的与机器学习相关的功能，比如情感分析，搜索辅助，图片识别等，这将对他们应用的体验有很大提升，并且也不需要很高的成本。</p><h2 id="Create-ML-仍有要“好好反思”的余地"><a href="#Create-ML-仍有要“好好反思”的余地" class="headerlink" title="Create ML 仍有要“好好反思”的余地"></a>Create ML 仍有要“好好反思”的余地</h2><p>苹果这些年在机器学习投入了很多，但毕竟作为一个“后来者”，还有一些问题需要解决。</p><h3 id="仍然不够成熟"><a href="#仍然不够成熟" class="headerlink" title="仍然不够成熟"></a>仍然不够成熟</h3><p>和隔壁使用 Python 生态的机器学习圈相比，苹果和 Swift 仍然有挺长的路要走。虽然 Create ML 包含了 Image，Video，Motion，Sound，Text 和 Table 的类别，但是其中暂时也是只有一些特定的 Template 可以使用，还是略显单薄。</p><h3 id="无法在云端训练"><a href="#无法在云端训练" class="headerlink" title="无法在云端训练"></a>无法在云端训练</h3><p>虽然在 Mac 上就能进行 Training 听起来非常美好，但是缺乏在云端训练的功能还是一个比较值得注意的问题。如果想让更多的用户转移到 Create ML 这个平台势必要考虑这个问题。但如果 Create ML 的定位就是轻量级别的 Training 的话，这可能也算不上一个问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从苹果这些年的一系列动作可以看出他们对于机器学习的生态有很大的野望，和谷歌等大公司的明争暗斗也让人看得眼花缭乱。谷歌也在积极推进 Swift for TensorFlow，从侧面也能看出谷歌对他这个对手的尊重。在我们凡人围观这场“神仙打架”的过程中也能看出来 Create ML 的出现更像一场即将或正在发生的革命 - 曾经机器学习的大部分资源都掌握在少数“AI精英”的手中，Create ML 的出现有助于打破现有的 “机器学习垄断”，让更多的开发者能有一个像样的交通工具加入这个赛道，虽然比不上别人的兰博基尼，但是也算有了代步的工具。随着更多人的加入，全民机器学习的时代可能会比我们想象的更早到来，到时候作为非机器学习的开发者也将有机会把自己的想法转化成真正的产品，AI 相关的应用将犹如雨后春笋般的出现。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>感谢公司的这次机会以及苹果员工精彩的演讲和耐心的咨询。最后打个广告：落叶的一生就是为了归根吗？曾经的我也相信宿命论 - 程序员就是要 996 的，疫情是要被裁员的，出游是要自掏腰包的，五一是只有三天假的 … 仿佛死神与巴格达商人在萨拉马的相会，一切都是那么无力。直到我加入了猿辅导，我的世界观崩塌了：原来程序员也不一定非要 996，疫情期间会有更多的项目和机会，出游是公司掏钱，五一有九天假！从来没见过如此“不讲武德”的公司，说好的武林要以和为贵呢？你这样其他公司怎么活！那你还在等什么，加入我们，我的邮箱是 <a href="mailto:goupy@fenbi.com" target="_blank" rel="noopener">goupy@fenbi.com</a>，内推我是认真的，你值得拥有更好的。</p><div class="note info"><p>相关链接：</p><p><a href="https://www.notion.so/Create-ML-84d28aa842064be7b74eb3bde136bd93" target="_blank" rel="noopener">笔记 - 基于 Create ML 的物体识别</a><br><a href="https://machinethink.net/blog/new-in-apple-machine-learning-2020/" target="_blank" rel="noopener">Apple machine learning in 2020: What’s new?</a><br><a href="https://www.raywenderlich.com/5653-create-ml-tutorial-getting-started#toc-anchor-020" target="_blank" rel="noopener">Create ML Tutorial: Getting Started</a><br><a href="http://www.cocoachina.com/articles/26420" target="_blank" rel="noopener">WWDC 2018：初探 Create ML</a><br><a href="https://www.zhihu.com/question/41979241" target="_blank" rel="noopener">什么是迁移学习 (Transfer Learning)？这个领域历史发展前景如何？</a><br><a href="https://www.netguru.com/codestories/createml-start-your-adventure-in-machine-learning-with-swift" target="_blank" rel="noopener">CreateML: Start Your Adventure in Machine Learning with Swift</a><br><a href="https://hongchaozhang.github.io/blog/2018/06/15/introducing-create-ml/" target="_blank" rel="noopener">Introducing Create ML</a><br><a href="https://heartbeat.fritz.ai/sound-classification-using-core-ml-3-and-create-ml-fc73ca20aff5" target="_blank" rel="noopener">Sound Classification on iOS Using Core ML 3 and Create ML</a><br><a href="https://www.computerworld.com/article/3293446/why-apple-s-create-ml-matters-to-your-enterprise.html" target="_blank" rel="noopener">Why Apple’s Create ML matters to your enterprise</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是苹果线上活动 - 基于 CreateML 的物体识别的观后感和一点想法。&lt;br&gt;
    
    </summary>
    
      <category term="会议报告" scheme="http://cyberhex.me/categories/%E4%BC%9A%E8%AE%AE%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Machine Learning" scheme="http://cyberhex.me/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 08</title>
    <link href="http://cyberhex.me/2020/08/02/arts-08/"/>
    <id>http://cyberhex.me/2020/08/02/arts-08/</id>
    <published>2020-08-02T10:40:53.000Z</published>
    <updated>2020-08-02T14:42:10.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>朋友圈（LeetCode 547，中等）</p><p>这道题是并查集考察的最经典的一道题了（当然也可以用 BFS，但总感觉比较山寨），因为并查集有几个比较基本的特性（查找两个节点是不是有同一个父亲，集合里边总共有多少个区块）正好有适用于这道题的特性。需要注意的就是要自己的得把并查集实现出来。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="http://rx-marin.com/post/rxswift-rxcocoa-sample-split-laps-timer/" target="_blank" rel="noopener">Split laps timer with RxSwift and RxCocoa</a></p><p>Marin 老哥的博客关注很久了，每次都是碰到问题会去看，这次准备从头开始系统的看一下他的博客，第一篇比较简单，就从第二篇开始写感想。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://cyberhex.me/2020/05/16/flutter-setup/">跨端开发的终极解决方案？- Flutter 学习历程之环境配置采坑记录</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;朋友圈（LeetCode 547，中等）&lt;/p&gt;
&lt;p&gt;这道题是并查集考察的最经典的
      
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 07</title>
    <link href="http://cyberhex.me/2020/07/26/arts-07/"/>
    <id>http://cyberhex.me/2020/07/26/arts-07/</id>
    <published>2020-07-26T14:47:16.000Z</published>
    <updated>2020-07-26T15:41:22.481Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>课程表II（LeetCode 210，中等）</p><p>这道题算是拓扑排序的经典了（刷了好几遍了，这周好多事偷个懒）。当然底层的算法还是万年不变的 BFS，算是比较好理解，唯一需要的注意的就是入度的定义，这个是这道题除了 BFS 之外的关键。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>这周看的东西都写在了分享的博客里，主要想说一下这周同事关于 OpenGL 的分享。之前由于苹果对于 OpenGL 有比较好的封装，所以很少接触到它，但是听了分享以后才发现自己对于许多苹果底层的东西知之甚少，比如 OpenGL，比如 Metal。听闻说 Metal 还是 CoreML 的基础（亏我还翻译过关于 CoreML 的文章，惭愧啊），之后在做完单测和 Flutter 分享以后要多花花时间看看这些底层的东西（包括 CoreAnimation 也是云里雾里的）。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>每次最头疼的就是 Tips 了，但是今天发现一个挺有用的小技巧。之前在 Swift 中使用 Selector 总感觉很山寨，还要写个 #selector，奇奇怪怪的，但是有一种很优雅的解决方式就是在当前文件中写一个 private 的 extension，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">extension</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> didTapButton = #selector(<span class="type">ViewController</span>.handleButtonTapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后使用的时候就可以这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.addTarget(<span class="keyword">self</span>, action: .didTapButton, <span class="keyword">for</span>: .touchUpInside)</span><br></pre></td></tr></table></figure><p>真的看起来舒服很多！</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 06</title>
    <link href="http://cyberhex.me/2020/07/20/arts-06/"/>
    <id>http://cyberhex.me/2020/07/20/arts-06/</id>
    <published>2020-07-19T16:35:51.000Z</published>
    <updated>2020-07-19T17:15:56.706Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>K 个一组翻转链表（LeetCode 25，困难）</p><p>这个题真的是就算知道怎么做也是要写错好几回，我这次的 AC 率是 6，感觉链表的题还是要多练才行。还有 Dummy Node 的技巧也很重要。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>这周看了这篇教程：<a href="https://www.raywenderlich.com/7408-testing-your-rxswift-code#toc-anchor-005" target="_blank" rel="noopener">Testing Your RxSwift Code</a></p><h3 id="RxTest-VS-RxBlocking"><a href="#RxTest-VS-RxBlocking" class="headerlink" title="RxTest VS. RxBlocking"></a>RxTest VS. RxBlocking</h3><p>两个在 Rx 的测试中都非常有用，RxBlocking 更加直观，RxTest 更加全面。</p><p>RxTest 可以覆盖大部分测试，而且 TestScheduler 模拟的虚拟时间可以大大缩短测试时间，但是写起来比较长也比较麻烦</p><p>相比 RxBlocking 写起来非常简单也直观，但使用场景比较局限，其中对我们来说比较致命的一点是 RxBlocking 对于无法停止的序列的测试能力很有限，并不能提供我们需要的能力。而我们直播中大部分序列都是无限序列，所以暂时不考虑 RxBlocking。</p><p>还有一点就是，RxBlocking 无法测试时间相关的用例，比如我在 1s的时候收到一个信号，想测试输出是否在 1s的时候输出某个特定值，RxBlocking 只能测试出来收到了这个值，但是不能确定时间戳。RxBlocking 比较适合测试初始值，或者只有一个状态的序列。</p><p>RxBlocking 也会 block 住当前线程，所以之前发生过的，测试走到 RxBlocking的语句之后，就会卡死并且无法继续进行测试也是这个引起的（我们使用了 BehaviorRelay 是无限序列）。</p><p>所以之后的测试还是需要继续使用 RxTest，以上。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>这次没发现特别骚的套路，所以先鸽了</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><h3 id="什么时候需要写单测"><a href="#什么时候需要写单测" class="headerlink" title="什么时候需要写单测"></a>什么时候需要写单测</h3><p>并不是所有的代码都需要你写单测来保证的，总结起来就是“三个不一个要”：</p><ol><li>不给自动生成的代码写 Unit Test（比如生成的 getter setter），我们要相信 Xcode（或者其他编辑器），出了问题是天灾，需要我们单独分情况处理，然后给我们自己处理的代码写单测。</li><li>不给编译器能发现的问题写 Unit Test，这个不是你需要关心的。</li><li>不给第三方库写 Unit Test，所谓疑人不用，用人不疑，你既然辛辛苦苦选择了一个靠谱的第三方库，就要相信他。如果出问题的话处理方式同第一点。</li><li>要给自己写的无法用编译器发现问题的代码写 Unit Test，包括自己写的 Class，Method 等。</li></ol><p>总结一下，上边的原则看起来挺多，其实就是一句话：上帝的归上帝，凯撒的归凯撒，自己的锅自己背，别人的锅我不管。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 尾声</title>
    <link href="http://cyberhex.me/2020/07/07/tdd-part-five/"/>
    <id>http://cyberhex.me/2020/07/07/tdd-part-five/</id>
    <published>2020-07-06T16:57:32.000Z</published>
    <updated>2020-07-20T15:01:33.376Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷五），本系列链表头部请戳 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷五），本系列链表头部请戳 &lt;a href=&quot;https://cyberhex.me/2020/06/14/tdd-part-one/&quot;&gt;A song of TDD and BUG - 前奏曲&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 变奏曲</title>
    <link href="http://cyberhex.me/2020/07/07/tdd-part-four/"/>
    <id>http://cyberhex.me/2020/07/07/tdd-part-four/</id>
    <published>2020-07-06T16:47:32.000Z</published>
    <updated>2020-11-30T16:32:14.400Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷四），本系列链表头部请戳 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a><br><a id="more"></a></p><h2 id="All-About-Change"><a href="#All-About-Change" class="headerlink" title="All About Change"></a>All About Change</h2><h2 id="劝分不劝和"><a href="#劝分不劝和" class="headerlink" title="劝分不劝和"></a>劝分不劝和</h2><h2 id="Dependency-Map"><a href="#Dependency-Map" class="headerlink" title="Dependency Map"></a>Dependency Map</h2><h2 id="历史代码-TDD-改造需要注意的问题"><a href="#历史代码-TDD-改造需要注意的问题" class="headerlink" title="历史代码 TDD 改造需要注意的问题"></a>历史代码 TDD 改造需要注意的问题</h2><h3 id="Start-Small"><a href="#Start-Small" class="headerlink" title="Start Small"></a>Start Small</h3><h3 id="Choose-Your-BattleField"><a href="#Choose-Your-BattleField" class="headerlink" title="Choose Your BattleField"></a>Choose Your BattleField</h3><p>记得写单测并不是你的目的，减少 Bug 才是，所以我们需要把有限的精力放在收益最大的单侧上。我推荐两种选择写单测优先级的方案：</p><ol><li>利用时间局部性：就像 LRU 的思想一下，在最近一段时间修改过的逻辑很有可能在未来一段时间内也需要修改，所以选择用单侧保证这部分逻辑有助于之后的迭代和重构。</li><li>“从”新开始：主意是从新，不是重新，也就是暂时考虑放弃之前的逻辑，对新业务使用 TDD 的开发模式来开发。这种比较适合没有时间对老代码进行重构和改造的情况，先对新的业务进行单测，等到业务稳定以后再考虑之前的历史包袱。</li></ol><h2 id="结语与鸣谢"><a href="#结语与鸣谢" class="headerlink" title="结语与鸣谢"></a>结语与鸣谢</h2><p>感谢同事们（海春，超超等）在我迷茫的时候的帮助，感谢强哥对整个系列的 review 和宝贵意见。最后打个广告：落叶的一生就是为了归根吗？曾经的我也相信宿命论 - 程序员就是要 996 的，疫情是要被裁员的，出游是要自掏腰包的，五一是只有三天假的 … 仿佛死神与巴格达商人在萨拉马的相会，一切都是那么无力。直到我加入了猿辅导，我的世界观崩塌了：原来程序员也不一定非要 996，疫情期间会有更多的项目和机会，出游是公司掏钱，五一有九天假！从来没见过如此“不讲武德”的公司，说好的武林要以和为贵呢？你这样其他公司怎么活！那你还在等什么，加入我们，我的邮箱是 <a href="mailto:goupy@fenbi.com" target="_blank" rel="noopener">goupy@fenbi.com</a>，内推我是认真的，你值得拥有更好的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷四），本系列链表头部请戳 &lt;a href=&quot;https://cyberhex.me/2020/06/14/tdd-part-one/&quot;&gt;A song of TDD and BUG - 前奏曲&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 副歌</title>
    <link href="http://cyberhex.me/2020/07/07/tdd-part-three/"/>
    <id>http://cyberhex.me/2020/07/07/tdd-part-three/</id>
    <published>2020-07-06T16:37:20.000Z</published>
    <updated>2020-07-30T06:56:21.122Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷三），本系列链表头部请戳 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a><br><a id="more"></a></p><h2 id="副歌不副，FTDD-不-F"><a href="#副歌不副，FTDD-不-F" class="headerlink" title="副歌不副，FTDD 不 F"></a>副歌不副，FTDD 不 F</h2><p>可能你在想，不是 A song of TDD and BUG 吗？怎么都到了副歌部分了，还没怎么说 TDD。这个可能就要怪我们民国的大师们把 Chorus 翻译成副歌了，明明是最高潮的部分，翻译成副歌总给人一种莫名其妙的感觉，不过也可能是我乐理不精对大师的翻译没有深刻理解导致的。那吐槽吐完，开始讲正事，之前有给过大家一个强烈但不失友善的警告大家应该还记得吧，不记得的可以去复习一下 <a href="https://cyberhex.me/2020/07/07/tdd-part-two/">A song of TDD and BUG - 主歌</a>。那会我说过适合自己的才是最好的，俗话说的好，规则就是用来打破的，只要我们了解了 TDD 的真谛，就可以把它改造成最适合自己的开发模式，我把这些 TDD 的变种们称为 FTDD。那何谓 FTDD，这个多出来的 F 代表什么？其实就是 Fu..，不好意思，是 Fake，也就是“伪 TDD”。那为什么说 FTDD 不 F 呢？因为这个“伪”并不是真正意义上的伪，而是结合了自己对 TDD 的理解和实践的产物，也可以理解为 F(it)TDD，也就是合适的 TDD。</p><h2 id="走进-TDD"><a href="#走进-TDD" class="headerlink" title="走进 TDD"></a>走进 TDD</h2><p>在 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a> 中我已经提到过 TDD 的基本步骤，不知道你还记得不，我再重复一遍：</p><ol><li>写一个失败的单元测试</li><li>完善代码让测试通过</li><li>重构</li><li>重复上述步骤到天荒地老</li></ol><p>上边的步骤又被叫做 Red-Green-Repeat Cycle, 虽然看起来简简单单几个步骤，但是其实都是有不同的考量的。</p><p>首先我们从第一个开始说，看到第一个的时候不知道你怎么想，我的第一反应是这个步骤太蠢了吧，我还没写代码，为啥先要写个失败的单元测试。但如果我们结合单测的编写原则就不难理解了，其中有一条是单测必须是可失败的，所以我们先写一个失败的单测是为了证明它是可失败的。当然这条比较有争议，因为你完全可以写完一部分功能了再写单测，重要的是不要留一个空的单测，这不仅是浪费时间，更重要的是我们在以后很有可能以为自己这部分代码是由单测保证的而耽误了找 Bug。</p><p>第二个步骤当然不言自明，我们的目的就是这个。但是这里边还是隐藏着一个前提，就是每次在写一个新的单测之前要先确保之前所有单测都跑通过。这个除了提醒你项目现在状态很好之外，还有一个很重要的作用是保证单测的可重复性。你不是每次只单独跑一个单测，而是没写一个就会把全部单测都跑一遍。</p><p>其实在第二个步骤中还有一个隐性的作用，就是保证单测的高效性（这个是编写单测的第三个原则），由于需要频繁的跑单测，你就必须把单测写的很节省时间（100 ms 阈值）。</p><p>第三个是重构，需要注意的是，如果重构对于整个单元的对外接口有改动的话，你需要同时修改单元测试以保持它们之间的同步。不过如果你不修改接口的话有很大可能单测会是你重构的保护神。</p><p>第四个步骤很好理解，就是重复上述步骤直到没有新的需求，我用天荒地老应该不过分吧。</p><h2 id="细测不是胡测"><a href="#细测不是胡测" class="headerlink" title="细测不是胡测"></a>细测不是胡测</h2><blockquote><p>单测不是万能的，但没有单测是万万不能的。</p></blockquote><p>不好意思我“借鉴”了三国杀里陆逊的台词（读书人的事怎么能叫抄呢），但我觉得用这个能精准表达我的意思。从上边的部分我们可以看出 TDD 非常看重单测覆盖率，有一种单测能解决一切的感觉。不得不承认，如果我们能覆盖所有分支并模拟所有可能出现的情况，理论上应该可以实现完全覆盖。但是现实很骨感，我们必须要考虑成本因素。</p><p>这部分的标题是“借用”了某表演艺术家的名言。这里的“细测”指的是高效率的单测，而“胡测”指的是盲目的给什么都做单测，盲目的追求100%的测试覆盖率成本很高，总体收益也不大。那我们可以猜测一下 Rainstorm 中哪些单测是高效的，哪些是低效的？估计你已经猜出来，网络代码的测试是高效的，而 ViewModel 中输出的单测是低效的。那具体是什么原因呢？我们对比一下这两种代码的不同，网络代码逻辑相对复杂，分支比较多，在真正输出之前，输入经过了好几次转手；而 ViewModel 的输出仅仅是把 Model 中的数据转换了一下格式输出，而这个转格式的工作也是有系统自带的库实现的。由此我们可以看出，那些给逻辑复杂，容易出错的代码写单测边际收益更大。并不是说 ViewModel 的单测没有任何意义，而是如果我们只有给一个部分写单测，我们应该写给网络代码。</p><h2 id="薛定谔的单元"><a href="#薛定谔的单元" class="headerlink" title="薛定谔的单元"></a>薛定谔的单元</h2><p>不知道你有没有仔细想过单元测试中的单元到底代表什么，是变量，方法，Class，还是模块？答案是都是，也都不是。你可能在想，怎么会有如此量子的概念？这是因为单元测试中的单元在被定义之前可以是上边说的任何一种存在，直到你定义了它才会有具体的意义，我愿称之为薛定谔的单元。</p><h2 id="测试粒度"><a href="#测试粒度" class="headerlink" title="测试粒度"></a>测试粒度</h2><p>在这里我就想引入一个概念，叫测试粒度。上边说了，对于单元我们可以选择它是变量，方法，Class，甚至是模块。这个对于单元的选择就是粒度，选择越大的区块意味着越粗的粒度，比如 Class 的粒度就比方法的粒度要粗。</p><h3 id="粒度的囚徒困境"><a href="#粒度的囚徒困境" class="headerlink" title="粒度的囚徒困境"></a>粒度的囚徒困境</h3><p>囚徒困境是指个体的理性选择往往导致群体的非理性。放在这里就是，细粒度的最大化的测试往往导致更粗力度的测试的困难。假设我们在方法的维度做了最大化的测试（给 private 的方法也做了测试），对于 Class 维度来说，测试代码和代码结构的耦合度太高，这个带来的问题就是，每当你给 Class 做重构的时候（重构意味着改变代码的内部结构而不改变其对外的行为），有很多单测就会挂掉。这意味着你又要重新写这些单测，这样的话单测就失去了你重构守护者的身份，反而成为了重构的负担。更严重的是，你会越来越反感单测，最后选择放弃。</p><h3 id="选择合适的测试粒度"><a href="#选择合适的测试粒度" class="headerlink" title="选择合适的测试粒度"></a>选择合适的测试粒度</h3><p>想解决上边所说的困境，第一步就是要选择一个合适的测试粒度，在这里我推荐选择 Class 作为单元的测试粒度，因为这样对于维护代码和重构都比较友好。</p><p>在定下了合适的测试粒度之后，我们就需要再思考一个问题，什么样的代码需要写单测？你可能会问了，这个问题不是在上一篇 <a href="https://cyberhex.me/2020/07/07/tdd-part-two/">A song of TDD and BUG - 主歌</a> 中讨论过了吗？但在这里我们想讨论的是给哪些代码写单测更高效。这就有点像法律和道德之前的关系，之前讨论的规则是基本法，是你不能逾越的红线，弄不好是要坐牢的。但是现在讨论的更像道德，你可以选择不去遵循，但是遵循了可以让你谈笑风生。</p><p>这里要遵循的的原则就是要测试单元可观测的行为，你需要这样想：我的输入时 x 和 y，输出是不是 z？而不是：我的输入是 x 和 y，是不是调用了 A 类的方法 f，然后返回方法的返回值 z。private 方法应该被视为实现细节，如果不是非常需要，我们不应该主动去测试他们。所以我们更需要关注的是 public 的接口，相应的也应该对接口进行测试。比如我的做法就是用 Xcode 生成需要测试 Class 的接口文件，看有哪些输出，然后用不同的输入来测试是否能得到想要的输出。</p><h3 id="更高级别的测试"><a href="#更高级别的测试" class="headerlink" title="更高级别的测试"></a>更高级别的测试</h3><p>如果我再扩大测试粒度的话，比如把单元变成整个流程甚至整个 App，量变引起质变，这个就超出单元测试的范畴进入集成测试或者是验收测试的范畴了。与之相对应的，测试的成本会上升，效率会下降。那你可能会问了，既然大粒度的测试如集成测试有更高的成本和更低的效率，它们为什么还会存在？</p><p>我们在写单测的时候会主动地去移除外部依赖以保证单元测试的单元性，但是外部环境（数据库，文件系统，向其他应用发起网络请求）也是软件系统中非常重要的一部分，所以我们需要编写一些测试可以覆盖到这些依赖。</p><p>接下来我们就说一下集成测试：在编写集成测试的时候我们应该尽可能的在本地运行外部依赖。拿 Rainstorm 来举例，如果要做集成测试，我们就需要在本地起一个服务器来充当 DarkSky API 的角色，然后对整个流程进行测试。</p><h2 id="测试金字塔"><a href="#测试金字塔" class="headerlink" title="测试金字塔"></a>测试金字塔</h2><p>从上边我们知道了测试是分层级的，对于他们之间的关系有一个很好的比喻-测试金字塔。你可能会想，为啥是金字塔，不是长城，不是空中花园？这是因为理想情况下，越低层级的测试的占有率应该越高。如下图（这张图是从网上扒的，就大概表达一下意思，并不是说我们一定要按照图里的测试层级去设计自己的测试）：</p><p><img src="https://martinfowler.com/bliki/images/testPyramid/test-pyramid.png" alt="Testing Pyramid"></p><p>从图中我们也可以看到他想表达的意思就是越高层级的测试效率会下降，成本会上升。</p><p>以 Rainstorm 为例，我们可以参考的测试金字塔从低到高可以是：单元测试 -&gt; 集成测试 -&gt; UI 测试 -&gt; 人工测试。不过这个还是要看不同项目的不同需求。</p><h3 id="Depth-Of-Test"><a href="#Depth-Of-Test" class="headerlink" title="Depth Of Test"></a>Depth Of Test</h3><p>这个概念是我在这篇博客 <a href="http://fabiopereira.me/blog/2012/03/18/introducing-depth-of-test-dot/" target="_blank" rel="noopener">Introducing Depth of Test (DOT)</a> 中看到的，文中借用了摄影中景深（Depth of Field）的概念，定义了 Depth Of Test（测试深度） 为在一次测试中所启动的最近软件原件（software component）到最远软件元件之间的距离。这个软件元件可以代表 Class 或 Function 甚至模块等等。</p><p>下边我继续以 <a href="https://github.com/quintessencegpy/Rainstorm" target="_blank" rel="noopener">Rainstorm</a> 为例说明一下测试深度。在我们对 RootViewModel 做单测的时候，我们想测试是否能通过网络层代码拿到正确的数据，我们的测试时候软件元件的路径是这样的：从 MockLocationService 中拿到位置数据，传递给 MockNetworkService 然后得到输出。由此可见我们的测试深度是 2。现在假设我们用人工的方式来测试，App 的流程是：进入页面后 RootViewController 会初始化 RootViewModel，然后 RootViewModel 通过 LocationManager（底层是 CLLocation） 请求位置，收到位置后由 NetworkManager（底层是 URLSession）再向 DarkSky API 请求天气数据，得到天气数据后通过 RootViewModel 生成 DayViewModel，然后由 DayViewController 来展示天气数据（在得到天气数据之后的数据流动在计算测试深度的时候我们可以暂时忽略）。在上边这次测试中最近的软件元件是 RootViewController 而最远的软件元件是 URLSession，所以测试深度是 6。</p><p>有了测试深度这个概念我们就可以发现，其实金字塔从底层到高层其实就是测试深度从浅到深的不同。这也解释了为什么金字塔层级越高的测试效率越低。</p><h3 id="金字塔-VS-冰激凌"><a href="#金字塔-VS-冰激凌" class="headerlink" title="金字塔 VS. 冰激凌"></a>金字塔 VS. 冰激凌</h3><p>前边说了理想状态下的测试层级是金字塔形状的，但是有理想就有苟且，那金字塔的对立面就是另一种模式 - 冰激凌模式，下边两张图就是两种不同模式的对比。</p><p>金字塔：<br><img src="https://miro.medium.com/max/1400/1*yBtEl6upLogDbvGG7nPRPw.jpeg" alt="Testing Pyramid"><br>冰淇淋：<br><img src="https://miro.medium.com/max/1400/1*I7izE-QRFNYl9nDxggbO8g.jpeg" alt="Ice cream cone anti-pattern"></p><p>看冰激凌模式眼熟的在评论区刷波 1。</p><p>冰激凌模式存在的问题就是平均测试深度过深，相应的测试效率和成本都会比金字塔模式表现得差。</p><h3 id="测试下沉原则"><a href="#测试下沉原则" class="headerlink" title="测试下沉原则"></a>测试下沉原则</h3><blockquote><p>如果一个更高层级的测试发现了一个错误，并且底层测试全都通过了，那么你应该写一个低层级测试去覆盖这个错误。</p></blockquote><p>如果在底层测试（单元测试）完全通过的情况下，我们在更高层的测试中（比如 UI 测试或者人工测试）中发现了一个 Bug， 我们应该在更底层补充相应的测试来覆盖这种情况。因为低层级测试让你更容易缩小错误的范围并且有更高的运行效率。</p><p>另外需要注意的一点就是，如果底层的测试已经完全能够覆盖之前发现的问题，可以选择在高层的测试中删除这部分测试，这样可以避免重复测试。如果问题评估比较重要，可以保留，因为这样可以增加上线的自信度。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本章粗略总结了一下 TDD 的基本步骤和单元测试之外的几个重要的测试。一个很重要的概念就是测试金字塔，这个是所有测试的基本哲学，在构架你的 FTDD 的时候一定要考虑到。</p><div class="note info"><p>相关链接：</p><p><a href="https://insights.thoughtworks.cn/practical-test-pyramid/" target="_blank" rel="noopener">测试金字塔实战</a><br><a href="https://martinfowler.com/bliki/TestPyramid.html" target="_blank" rel="noopener">TestPyramid</a><br><a href="https://www.thoughtworks.com/insights/blog/introducing-software-testing-cupcake-anti-pattern" target="_blank" rel="noopener">Introducing the Software Testing Cupcake (Anti-Pattern)</a><br><a href="https://jamescrisp.org/2011/05/30/automated-testing-and-the-test-pyramid/" target="_blank" rel="noopener">Automated Testing and the Test Pyramid</a><br><a href="http://fabiopereira.me/blog/2012/03/18/introducing-depth-of-test-dot/" target="_blank" rel="noopener">Introducing Depth of Test (DOT)</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷三），本系列链表头部请戳 &lt;a href=&quot;https://cyberhex.me/2020/06/14/tdd-part-one/&quot;&gt;A song of TDD and BUG - 前奏曲&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 主歌</title>
    <link href="http://cyberhex.me/2020/07/07/tdd-part-two/"/>
    <id>http://cyberhex.me/2020/07/07/tdd-part-two/</id>
    <published>2020-07-06T16:27:20.000Z</published>
    <updated>2020-07-29T18:57:53.350Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷二），本系列链表头部请戳 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a><br><a id="more"></a></p><h2 id="FBI-Warning"><a href="#FBI-Warning" class="headerlink" title="FBI Warning"></a>FBI Warning</h2><p>我知道你在想啥，但是你想多了，我只是想给你一个强烈但不失友善的警告（Friendly But Intense Warning）而已。在了解 TDD 之前你需要知道，TDD 只是一种开发模式，不是圣经也不是行为准则，我们需要辩证的去看待 TDD，可以参照 TDD 并且结合自己的实际情况选择最适合自己的开发模式，毕竟适合自己的才是最好的。这你可能会问了，刚你还说 TDD 又是最耀眼的新星，又是救世主的，现在咋又说人家坏话。我想说的是，你毕竟还是 Too Young，要我不进行一波商业吹嘘，你可能也不愿意往下看啊，流量称王的时代，我不得忽悠你多看几眼啊。</p><h2 id="什么代码需要写单测"><a href="#什么代码需要写单测" class="headerlink" title="什么代码需要写单测"></a>什么代码需要写单测</h2><p>并不是所有的代码都需要你写单测来保证的，总结起来就是“三个不一个要”：</p><ol><li>不给自动生成的代码写 Unit Test（比如生成的 getter setter），我们要相信 Xcode（或者其他编辑器），出了问题是天灾，需要我们单独分情况处理，然后给我们自己处理的代码写单测。</li><li>不给编译器能发现的问题写 Unit Test，这个不是你需要关心的。</li><li>不给第三方库写 Unit Test，所谓疑人不用，用人不疑，你既然辛辛苦苦选择了一个靠谱的第三方库，就要相信他。如果出问题的话处理方式同第一点。</li><li>要给自己写的无法用编译器发现问题的代码写 Unit Test，包括自己写的 Class，Method 等。</li></ol><p>总结一下，上边的原则看起来挺多，其实就是一句话：上帝的归上帝，凯撒的归凯撒，自己的锅自己背，别人的锅我不管。</p><h2 id="如何做一只合格的单测"><a href="#如何做一只合格的单测" class="headerlink" title="如何做一只合格的单测"></a>如何做一只合格的单测</h2><p>如果单测界也需要面试，那单测的招聘广告一定是下面这样的：</p><ol><li>你必须是可失败的，禁止使用如 Assert True 为 True 这样的作弊手段来保证自己的正确性，一经发现，必将诉诸法律手段。</li><li>你必须是可重复的，不能在多次的测试中给出不同的结果，否则你就会失去工作。</li><li>你必须是有效率的，不能干活磨磨唧唧的，可别忘了，我们这每次测试都需要跑很多单测，如果你处理工作超过 100 ms 就是不合格的。</li></ol><p>突然有点心疼单测的工作，但是我们能怎么办呢，人生不如意十有八九，更何况单测呢。</p><h2 id="单测的命名规则"><a href="#单测的命名规则" class="headerlink" title="单测的命名规则"></a>单测的命名规则</h2><p>这里有的小朋友就可能要问了，我写的单测我做主，我就要给他命名成 test1，test10086，testMyLove，你管我。这些小朋友一看就没有经历过社会的毒打，作为一个腿都被打断的过来人，我给你分享一点人生的经验。比如你刚进行了一次重构，突然发现有个名叫 testYouDidntGiveMeAMeaningfulNameAndNowYouSuckIt 的单测出了问题，你根本不知道他具体是代表了哪个地方出问题，你得需要在众单测中先找到这个单测，然后大概看一下测了什么并且心里一直在想给之前写单测的自己扇一大耳光，这会令你浪费很多宝贵的时间。在理解了命名的重要性后，下边我就分享一个比较通用的命名规则：</p><ol><li>对于每一个 class 有一个对应的 Unit Test 文件，命名规则为原文件名 + Tests，比如想给 ViewModel 写 Unit Test 就叫 ViewModelTests</li><li>测试函数名规则：test + 要被测试的函数名/变量名 +  _ + 状态 + _ + 所期望的结果，比如一个叫 state 的输出在初始化之后是否为 normal，函数名就应该是 testState_whenInit_isNormal</li><li>什么是 sut：sut stands for  “System Under Test”，平时我们用 sut 来表示需要被测试的对象，比如在 ViewModelTests 中 sut 就是 ViewModel 的实体，即 sut = ViewModel()</li></ol><h2 id="Given，When，Then"><a href="#Given，When，Then" class="headerlink" title="Given，When，Then"></a>Given，When，Then</h2><p>这三个是单元测试的三个基本步骤（如此 skr 的命名方式，相信前辈也是一名单压狂魔吧）：</p><ol><li>Given 是指初始状态，也就是 sut 的初始状态。</li><li>When 是指一个发生在 sut 上的事件或者状态变化。</li><li>Then 是指在状态变化后来测试 sut 的状态与期望的状态是否相同。</li></ol><h2 id="Gearing-Up"><a href="#Gearing-Up" class="headerlink" title="Gearing Up"></a>Gearing Up</h2><p>相信你已经摩拳擦掌，迫不及待的想开始了。但是少侠稍安勿躁，行走江湖没有一件趁手的装备怎么行。这里我就以 iOS 为例来探讨一下单测框架的选择。选择框架需要考虑几个方面的问题：</p><ol><li>学习成本：我把这个列在第一位，是因为时间就是金钱，谁也不愿意花费大量时间学习一个晦涩难懂的框架。</li><li>易用性：这个就不用我多说了吧，一个好用的框架能让你事半功倍，反之，事半功半半半。</li><li>可读性：这个也很重要，因为很多情况下单测只是用来测试代码的，也可以作为了解业务逻辑的一种方法。</li><li>附加价值：这个就很笼统了，比如有的框架内置 BDD，有的和其他库 - 比如 Mock 的库（为什么要把 Mock 单独拿出来说，之后你就会明白）- 更加贴合，这些都可以成为框架的附加价值。</li></ol><p>接下来我就以 iOS 中的两个常用的框架做一下比较，下边有请本段的双主角 XCTest 和 Quick &amp; Nimble。先交代一下故事的背景，XCTest 是苹果自带的单测框架，而 Quick &amp; Nimble 是基于 XCTest 发展出来的一个框架，具有非常独特的语法和使用方式，但是底层的 Assertion 等和 XCTest 非常相似。</p><p>我们先直观的看一下两个框架的测试代码都长什么样：</p><p>首先是苹果自带的 XCTest：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeekDayViewModelTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sut: <span class="type">WeekDayViewModel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Load Stub</span></span><br><span class="line">        <span class="keyword">let</span> data = loadStub(name: <span class="string">"darksky"</span>, <span class="class"><span class="keyword">extension</span>: "<span class="title">json</span>")</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        // <span class="title">Initialize</span> <span class="title">JSON</span> <span class="title">Decoder</span></span></span><br><span class="line"><span class="class">        <span class="title">let</span> <span class="title">decoder</span> = <span class="title">JSONDecoder</span>()</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        // <span class="title">Configure</span> <span class="title">JSON</span> <span class="title">Decoder</span></span></span><br><span class="line"><span class="class">        <span class="title">decoder</span>.<span class="title">dateDecodingStrategy</span> = .<span class="title">secondsSince1970</span></span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        // <span class="title">Initialize</span> <span class="title">Dark</span> <span class="title">Sky</span> <span class="title">Response</span></span></span><br><span class="line"><span class="class">        <span class="title">let</span> <span class="title">darkSkyResponse</span> = <span class="title">try</span>! <span class="title">decoder</span>.<span class="title">decode</span>(<span class="title">DarkSkyResponse</span>.<span class="title">self</span>, <span class="title">from</span>: <span class="title">data</span>)</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        // <span class="title">Initialize</span> <span class="title">View</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class">        <span class="title">sut</span> = <span class="title">WeekDayViewModel</span>(<span class="title">weatherData</span>: <span class="title">darkSkyResponse</span>.<span class="title">forecast</span>[5])</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">override</span> <span class="title">func</span> <span class="title">tearDown</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.tearDown()</span><br><span class="line">        sut = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testDay_whenGetData_isExpected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(sut.day, <span class="string">"Sunday"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testDate_whenGetData_isExpected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(sut.date, <span class="string">"September 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testTemperature_whenGetData_isExpected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(sut.temperature, <span class="string">"12.2 °C - 20.1 °C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testWindSpeed_whenGetData_isExpected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(sut.windSpeed, <span class="string">"5 MPH"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是倔强的 Quick &amp; Nimble：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeekDayViewModelTests</span>: <span class="title">QuickSpec</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">spec</span><span class="params">()</span></span> &#123;</span><br><span class="line">        describe(<span class="string">"a WeekDayViewModel"</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sut: <span class="type">WeekDayViewModel</span>!</span><br><span class="line">            </span><br><span class="line">            beforeEach &#123;</span><br><span class="line">                <span class="keyword">let</span> data = <span class="keyword">self</span>.loadStub(name: <span class="string">"darksky"</span>, <span class="class"><span class="keyword">extension</span>: "<span class="title">json</span>")</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                // <span class="title">Initialize</span> <span class="title">JSON</span> <span class="title">Decoder</span></span></span><br><span class="line"><span class="class">                <span class="title">let</span> <span class="title">decoder</span> = <span class="title">JSONDecoder</span>()</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                // <span class="title">Configure</span> <span class="title">JSON</span> <span class="title">Decoder</span></span></span><br><span class="line"><span class="class">                <span class="title">decoder</span>.<span class="title">dateDecodingStrategy</span> = .<span class="title">secondsSince1970</span></span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                // <span class="title">Initialize</span> <span class="title">Dark</span> <span class="title">Sky</span> <span class="title">Response</span></span></span><br><span class="line"><span class="class">                <span class="title">let</span> <span class="title">darkSkyResponse</span> = <span class="title">try</span>! <span class="title">decoder</span>.<span class="title">decode</span>(<span class="title">DarkSkyResponse</span>.<span class="title">self</span>, <span class="title">from</span>: <span class="title">data</span>)</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                <span class="title">sut</span> = <span class="title">WeekDayViewModel</span>(<span class="title">weatherData</span>: <span class="title">darkSkyResponse</span>.<span class="title">forecast</span>[5])</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">           </span></span><br><span class="line"><span class="class">            <span class="title">afterEach</span> </span>&#123;</span><br><span class="line">                sut = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"its day"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"is Sunday"</span>) &#123;</span><br><span class="line">                        expect(sut.day).to(<span class="built_in">equal</span>(<span class="string">"Sunday"</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"its date"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"it is September 2"</span>) &#123;</span><br><span class="line">                        expect(sut.date).to(<span class="built_in">equal</span>(<span class="string">"September 2"</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"its temperature"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"is 12.2 °C - 20.1 °C"</span>) &#123;</span><br><span class="line">                        expect(sut.temperature).to(<span class="built_in">equal</span>(<span class="string">"12.2 °C - 20.1 °C"</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"its windSpeed"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"is 5 MPH"</span>) &#123;</span><br><span class="line">                        expect(sut.windSpeed).to(<span class="built_in">equal</span>(<span class="string">"5 MPH"</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上边分别是两个框架对 WeekDayViewModel 的单元测试，你可以明显感觉到两个库的风格。说不定你可能就只是在库群中对其中某个多看了一眼，然后再也忘不掉它的优雅。但是选一个框架跟结婚一样，不止需要看对眼，还需要考虑很多现实的问题，要不然破裂的时候，就不只是“不和它一起维护代码”了那么简单了，还需要考虑重构，移除依赖，选择一个新的库一起维护代码，都说戏如人生，写代码也何尝不是如此呢。接下来，我就给你用上边的几个原则理性的分析一波，但是不管我分析的结果是什么，决定权都在你手上。可别忘了：人是感性的生物，如果是真爱，去他喵的理性分析。</p><ol><li>Round 1：学习成本。XCTest 作为苹果的亲儿子，不论文档还是教程都比 Quick &amp; Nimble 这个“孤儿”要多很多，再加上 Quick &amp; Nimble 的使用方式比较特别，需要一点适应的时间，所以第一局 XCTest 胜。</li><li>Round 2：易用性。其实如果花时间学习了其中任意一种框架的话，用起来的难易程度都差不多（当然这么说的比较主观，但是感觉应该不是有特别大的出入）。这一局算平局。</li><li>Round 3：可读性。XCTest 中每一个测试都是独立的，如果对于同一个属性有不同的测试，我们需要人工的把它们归在一起，如果稍有不慎，就很容易混乱难找（单测一般都挺长的，尤其是加了Mock 以后）。但是 Quick &amp; Nimble 我们可以天然的把相同属性的测试都归在同一个 describe 下边。所以这一局算 Quick &amp; Nimble 胜。</li><li>Round 4：附加价值。之前经过一番对比，两边各有胜负，最后又回到了起点，所以这一局算是胜负手。我主要想从对 BDD 的支持的方面来说，用 XCTest 你当然也可以结合 BDD 的思路来写单测，但是这个需要你人工的去维护。这时候 Quick &amp; Nimble 可就突然兴奋起来了，它对于 BDD 可是有天然的亲和力的。BDD 中的核心思想 GWT（也就是之前说过的 Given/When/Then）等价于 Quick &amp; Nimble 中的 descirbe，context，和 it（这几个在后边都会说到）。所以最终的 Winner 属于虽然是“孤儿”但仍能逆风 Carry 的 Quick &amp; Nimble。</li></ol><p>最后我还是想重申一下，上边的结论带有很大的主观性，对于不同的人来说结果肯定是有所出入的。但我觉得选择的过程还是可以被借鉴的，如果你有选择困难症的话，甚至可以参考 SWOT 分析法来选择。</p><h2 id="真正的开始"><a href="#真正的开始" class="headerlink" title="真正的开始"></a>真正的开始</h2><p><a href="https://github.com/quintessencegpy/Rainstorm" target="_blank" rel="noopener">Rainstorm</a> 是一个非常简单直观但是又能 cover 我想说的大部分内容的项目，他是一个单页面的 App，页面上半部分是实时的天气，下边是接下来几天的天气预报，在这里我就不截图了，感兴趣的可以按照 ReadMe 里的一步一步跑一下项目， 如果你是懒人党，就凭空脑补一下 iOS 自带天气 App就行。什么，你不是 iOS 用户？那你就随手百度一下图片。什么，不会百度？不好意思，杠精出门右转，ETC 在左手边。</p><p>关于如何创建项目和加入 Unit Test 我就不在这里赘述了，但是我需要提的一点是关于 Podfile。如果你是第一次在 Unit Test 加入 Pod 的话需要注意一下，因为在主项目中你并不会用到 Unit Test 的 Pod，但是在 Unit Test 中你大概率会用到主项目的 Pod，所以需要做一下下边的骚操作：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'Rainstorm'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Comment the next line if you don't want to use dynamic frameworks</span></span><br><span class="line">  use_frameworks!</span><br><span class="line">  pod <span class="string">'SnapKit'</span></span><br><span class="line">  <span class="comment"># Pods for Rainstorm</span></span><br><span class="line">  target <span class="string">'RainstormTests'</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line">    pod <span class="string">'Quick'</span></span><br><span class="line">    pod <span class="string">'Nimble'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>好了，废话说的够多了，我们开始写第一个单测。</p><h2 id="初识-Quick-amp-Nimble"><a href="#初识-Quick-amp-Nimble" class="headerlink" title="初识 Quick &amp; Nimble"></a>初识 Quick &amp; Nimble</h2><p>不知道你有没有注意到，之前在对比 XCTest 和 Quick &amp; Nimble 的示例代码中我用到了很多的 “！”符号，这个是 Swift 中的强解包，说到这里很多了解 Optional 的同学就要嘲讽我了，但我要给自己辩护一下，我这里是故意用强解包的，因为：首先，在单测中不需要进行错误处理；其次，如果在这里发生了 Crash，说明我犯了一个又蠢又挫的错误，需要及时解决。</p><p>接下来简单的说一下 Quick &amp; Nimble 的使用，我们先来看一下 Quick 官方文档中给的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableOfContentsSpec</span>: <span class="title">QuickSpec</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">spec</span><span class="params">()</span></span> &#123;</span><br><span class="line">    describe(<span class="string">"the 'Documentation' directory"</span>) &#123;</span><br><span class="line">      it(<span class="string">"has everything you need to get started"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> sections = <span class="type">Directory</span>(<span class="string">"Documentation"</span>).sections</span><br><span class="line">        expect(sections).to(contain(<span class="string">"Organized Tests with Quick Examples and Example Groups"</span>))</span><br><span class="line">        expect(sections).to(contain(<span class="string">"Installing Quick"</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      context(<span class="string">"if it doesn't have what you're looking for"</span>) &#123;</span><br><span class="line">        it(<span class="string">"needs to be updated"</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> you = <span class="type">You</span>(awesome: <span class="literal">true</span>)</span><br><span class="line">          expect&#123;you.submittedAnIssue&#125;.toEventually(beTruthy())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像之前说的，Quick &amp; Nimble，有三个层面 descirbe，context，和 it 分别对应 GWT（Given/When/Then）。套在上边的示例中就是：</p><ol><li>Given “the ‘Documentation’ directory”</li><li>When “it doesn’t have what you’re looking for”</li><li>Then “it needs to be updated”</li></ol><p>除此之外，常用的还有 beforeEach 和 afterEach，这两个名字就很能说明问题， 这两个 block 会在每个单测执行之前和之后执行，跟 XCTest 中的 setUp 和 tearDown 比较类似。博客的主要任务不是说 Quick &amp; Nimble，所以我就偷懒把学习资料放在这，需要的可以放到收藏夹里去吃灰：</p><ol><li><a href="https://www.raywenderlich.com/135-behavior-driven-testing-tutorial-for-ios-with-quick-nimble#toc-anchor-010" target="_blank" rel="noopener">Behavior-Driven Testing Tutorial for iOS with Quick &amp; Nimble</a></li><li><a href="https://github.com/Quick/Quick/tree/master/Documentation" target="_blank" rel="noopener">Quick Documentation</a></li></ol><h2 id="做单测永远滴神"><a href="#做单测永远滴神" class="headerlink" title="做单测永远滴神"></a>做单测永远滴神</h2><p>在单测中，你要有猛虎归山，蛟龙如海，王者混入青铜局的气势，要有那种掌控雷电，呼风唤雨的感觉才对。为什么要这么说呢，你需要对单测的输入，流程，输出有绝对的控制权。但是这个神不是你想做，想做就能做的，你需要两个非常忠实的奴仆 - 抽象层和 Mock。</p><h3 id="光能使者抽象层"><a href="#光能使者抽象层" class="headerlink" title="光能使者抽象层"></a>光能使者抽象层</h3><blockquote><p>单测的一个“副作用”就是揭开你代码的最后一块遮羞布 - 很多问题比如逻辑太分散，耦合度太高等问题都会会暴露无疑。因为这一次面对这些问题的人不再是别人，而是你自己。</p></blockquote><p>人们都说单测是检验代码质量的重要标准，有这种说法的很大原因都是抽象层的功劳，所以它也不愧光能使者，因为有了它你也就有了一把如意神剑（能看懂这个的都是老中二了）。那你肯定想说，吹了半天，总得说出点名堂吧。还记得那句经典名言吗？</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote><p>这个中间层放在这里指的就是抽象层。</p><p>拿 Rainstorm 来举例，因为我们是需要从网络拿到天气数据，然后才能展示。这时候你可能就会犯嘀咕，这种单测该怎么写？之前不是说了单测需要保证可重复性，我每次从网络拿到的数据又不可靠，怎么保证可重复性？如果你有这些疑问，说明你已经上道了，不愧是你小机灵鬼。其实这个问题答案就是这部分的核心思想，你要做单测永远滴神。既然从网络那边拿到的数据不可靠，我们就自己模拟，这也是马上要说的 Mock。但是模拟一次网络请求也太麻烦了，有没有什么更好的方法？这就可以回归主题 - 抽象层了。如果我们在 ViewModel（我只是以 MVVM 举例，可以是任何 class） 和 Networking 之间加一层抽象这个问题就迎刃而解。在 Rainstorm 中这个抽象层叫 NetworkService，它只是提供接口，所以不管数据是从网络来，还是单测中的 Stub，对于 ViewModel 来说都是透明的。这样一来，不仅解决了单测的问题，你的代码复用性也更高了。比如之后你想换网络层的库，只要接口不变，ViewModel 的代码就不用改。抽象层把路铺好了，接下来怎么操作就要看 Mock 的了。</p><h3 id="堕落天使-Mock"><a href="#堕落天使-Mock" class="headerlink" title="堕落天使 Mock"></a>堕落天使 Mock</h3><p>其实关于 Mock 还有一个更专业的名字 - Test Double，直译过来就是测试专用替身（有人翻译成置换测试，但是明显我翻译的更接地气哈哈哈）。而且 Mock 只是 Test Double 其中的一种。Test Double 包含 Fake，Mock，Stub。他们之间都有一些区别。由于关系过于错综复杂如同八卦，所以感兴趣的可以去看看这篇博客 <a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da" target="_blank" rel="noopener">Test Doubles — Fakes, Mocks and Stubs.</a>。在之后的博客中我就避开这些如同文字游戏一般的概念，直接简单认为 Mock 就是我们模拟生产环境的对象，Stub 是模拟生产环境的数据（比如从网络拿到的数据或者数据库里的数据）。</p><p>就像动漫钢之炼金术师里烧瓶中的小人一样，有时候最危险的人物或者说最终的 Boss 可能就隐藏在你身边，甚至可能是你最忠实的奴仆。在单测中，需要我们随时注意不被反咬一口的就是 Mock。这么说的原因是因为如果稍微不注意，Mock 就有可能变的像裹脚布一样，又臭又长。虽然在 Rainstrom 中没有出现这个问题，但是在一些复杂的项目中，有时候 Mock 一个对象可能需要先创建很多其他的“假”对象。但是有很多好用的 Mock 库可以用，一个比较出名的就是 <a href="https://github.com/Brightify/Cuckoo" target="_blank" rel="noopener">Cuckoo</a> ，有兴趣可以去了解一下。</p><p>在 Rainstrom 中我们为了测试专门创建了两个 Mock Class - MockLocationService 和 MockNetworkService。它们分别是遵循 LocationService 和 NetworkService 接口的。由于他们的存在，单测中的 Mock 变得轻松了很多。</p><h2 id="Networking-代码的单测"><a href="#Networking-代码的单测" class="headerlink" title="Networking 代码的单测"></a>Networking 代码的单测</h2><p>上一部分有提到 Networking 的测试，现在我们就来仔细说一下 Networking 代码的测试。接下来我就用最简单的方法来尝试给 RootViewModel 写一个单测。思路很简单，就是写一个假的 didFetchWeatherData，然后在回调中做 Assert 就可以了。下边是构想中的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootViewModelTests</span>: <span class="title">QuickSpec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">spec</span><span class="params">()</span></span> &#123;</span><br><span class="line">        describe(<span class="string">"a RootViewModel"</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sut: <span class="type">RootViewModel</span>!</span><br><span class="line">            <span class="keyword">var</span> networkService: <span class="type">MockNetworkService</span>!</span><br><span class="line">            <span class="keyword">var</span> locationService: <span class="type">MockLocationService</span>!</span><br><span class="line">            </span><br><span class="line">            beforeEach &#123;</span><br><span class="line">                <span class="comment">// Initialize Mock Network Service</span></span><br><span class="line">                networkService = <span class="type">MockNetworkService</span>()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Configure Mock Network Service</span></span><br><span class="line">                networkService.data = <span class="keyword">self</span>.loadStub(name: <span class="string">"darksky"</span>, <span class="class"><span class="keyword">extension</span>: "<span class="title">json</span>")</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                // <span class="title">Initialize</span> <span class="title">Mock</span> <span class="title">Location</span> <span class="title">Service</span></span></span><br><span class="line"><span class="class">                <span class="title">locationService</span> = <span class="title">MockLocationService</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">                // <span class="title">Initialize</span> <span class="title">Root</span> <span class="title">View</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class">                <span class="title">sut</span> = <span class="title">RootViewModel</span>(<span class="title">networkService</span>: <span class="title">networkService</span>, <span class="title">locationService</span>: <span class="title">locationService</span>)</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            </span></span><br><span class="line"><span class="class">            <span class="title">afterEach</span> </span>&#123;</span><br><span class="line">                sut = <span class="literal">nil</span></span><br><span class="line">                networkService = <span class="literal">nil</span></span><br><span class="line">                locationService = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"refreshing"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when get weatherData"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"get expected output"</span>) &#123;</span><br><span class="line">                        sut.didFetchWeatherData = &#123; (result) <span class="keyword">in</span></span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">case</span> .success(<span class="keyword">let</span> weatherData) = result &#123;</span><br><span class="line">                                <span class="built_in">print</span>(weatherData)</span><br><span class="line">                                expect(weatherData.latitude).to(<span class="built_in">equal</span>(<span class="number">37.8267</span>))</span><br><span class="line">                                expect(weatherData.longitude).to(<span class="built_in">equal</span>(-<span class="number">122.4233</span>))</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        sut.refresh()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信你如果跟着博客一直看，上边的代码应该比较好理解，然后如果跑一下单测会发现我们非常幸运，Test Succeeded 让我们感觉很有成就感。但是随手翻了一下 Console，你会发现事情并不简单。我在上边的代码中藏了一个小小的坑 - print(weatherData)。可我们在 Console 中并没有看到打印，这说明问题很严重，虽然我们测试成功了，然而其实代码根本就没有走到回调中，这是为什么呢？</p><h2 id="异步测试方法"><a href="#异步测试方法" class="headerlink" title="异步测试方法"></a>异步测试方法</h2><p>看到这个标题你应该就大概了解原因了。没错，Xcode 中的 Unit Test 是一个同步的过程，所以我们异步的代码并没有执行。Quick  &amp; Nimble 中有两种 方法可以进行异步测试的方法  waitUntil 和 toEventually。这两个都可以进行异步的测试，具体的用法可以看这个博客 <a href="https://www.mokacoding.com/blog/waituntil-vs-toeventually/" target="_blank" rel="noopener">Nimble: when to use waitUntil or toEventually</a>，在这我就选择 waitUntil。接下来我们就对上边的单测用 waitUntil 进行改写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    describe(<span class="string">"refreshing"</span>) &#123;</span><br><span class="line">        context(<span class="string">"when get weatherData"</span>) &#123;</span><br><span class="line">            it(<span class="string">"get expected output"</span>) &#123; </span><br><span class="line">                waitUntil &#123; (done) <span class="keyword">in</span></span><br><span class="line">                    sut.didFetchWeatherData = &#123; (result) <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">case</span> .success(<span class="keyword">let</span> weatherData) = result &#123;</span><br><span class="line">                            expect(weatherData.latitude).to(<span class="built_in">equal</span>(<span class="number">37.8267</span>))</span><br><span class="line">                            expect(weatherData.longitude).to(<span class="built_in">equal</span>(-<span class="number">122.4233</span>))</span><br><span class="line">                            <span class="built_in">print</span>(weatherData)</span><br><span class="line">                            done()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    sut.refresh()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们就可以看到，不仅单测成功了，Console 中也打印出来了我们期待已久的 weatherData，是不是非常简单。</p><h2 id="Happy-Path-vs-Unhappy-Path"><a href="#Happy-Path-vs-Unhappy-Path" class="headerlink" title="Happy Path vs. Unhappy Path"></a>Happy Path vs. Unhappy Path</h2><p>人生不如意十有八九，代码世界里虽然没有八九那么高，但是一些错误也是没有办法避免的。一些问题比如用户没有网络，无法 GPS 定位等问题都是可预期和可接受的。但不同的是，在代码中我们可以“开天眼”，提前为可能发生的问题部署，等到了发生的时候都可以优雅的处理这些问题。那这些所谓的 “Unhappy Path”是否需要单测呢？答案是何止是需要，那是相当需要。因为这些 Corner Case 的处理体现出了一个产品的下限，下限越高，越不容易翻车。</p><p>下边我就以无法获得用户位置为例写一下 Unhappy Path 的测试。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">context(<span class="string">"when failed to fetch location"</span>) &#123;</span><br><span class="line">    it(<span class="string">"get notAuthorizedToRequestLocation error"</span>) &#123;</span><br><span class="line">        locationService.location = <span class="literal">nil</span></span><br><span class="line">        </span><br><span class="line">        waitUntil &#123; (done) <span class="keyword">in</span></span><br><span class="line">            sut.didFetchWeatherData = &#123; (result) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">case</span> .failure(<span class="keyword">let</span> error) = result &#123;</span><br><span class="line">                    expect(error).to(<span class="built_in">equal</span>(<span class="type">RootViewModel</span>.<span class="type">WeatherDataError</span>.notAuthorizedToRequestLocation))</span><br><span class="line">                    done()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sut.refresh()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的测试中，我们把 locationService（类型是 MockLocationService）中的 location 设为空来模拟无法获取到用户位置。使用上边说到的异步测试的方法就可以测试我们是否能收到 notAuthorizedToRequestLocation 的错误。</p><h2 id="Rx，你个磨人的小妖精"><a href="#Rx，你个磨人的小妖精" class="headerlink" title="Rx，你个磨人的小妖精"></a>Rx，你个磨人的小妖精</h2><p>使用过 Rx 的小朋友们一定会有一个这样的感受：开发一时爽，Debug 火葬场。因为虽然使用 Rx 的时候虽然感觉数据流很清晰，但是真的出问题的时候 Debug 真的是要了老命，因为崩溃的堆栈真会让你看的怀疑人生。所以这种时候写单测就非常重要了，因为趁着你在开发的时候对业务逻辑比较了解的时候把问题解决，比之后出问题了再重新看代码要省好多时间和头发。</p><p>我也曾经有过用 waitUtil + subscribe 的方式进行过单测，但是效率真的是非常的低，尤其是 Time-Based Operator。想象你起了一个 3 秒间隔的 Timer。你在单测中就真的要等 3 秒来测试。听起来好像不多，但是你想如果有 100 这样的单测，你就需要等 300 秒！真的还不如把代码跑来来自己瞄一眼对不对呢。这也是之前在“如何做一只合格的单测”中提到的 100ms 阈值的原因。</p><p>由于 Rx 的特殊的使用方式和开发模式，我们需要一个新的框架来进行对 Rx 的单元测试，在 RxSwift 中就是 RxTest 和 RxBlocking。</p><h3 id="RxTest"><a href="#RxTest" class="headerlink" title="RxTest"></a>RxTest</h3><p>听这个名字就可以感觉到这个是 Rx 比较正统的测试方式了，毕竟都叫 RxTest。那它能怎么改变我们的测试方式呢？这就不得不说最大的功臣 TestScheduler。Scheduler 的作用跟 iOS 中线程有一点相似，但又不完全一样，我们平时用到比较多的就是 MainScheduler （RxSwift 中）。有兴趣的可以上百度谷歌一下，有很多的资料解释，我就不在这里多说了。那 TestScheduler 是什么呢，它其实就相当于生产代码中 Scheduler 的替身。但不同的是它在测试环境中使用的是虚拟时间，所以对于测试相当友好，就算我们用了一些 Time-Based Operator 我们也不用在测试中真的等那么长时间。下边我就假设 Rainstorm 中 RootViewModel 有一个输出叫做 isRefreshing，他是一个 PublishSubject，测试它的代码就如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"isRefreshing"</span>) &#123;</span><br><span class="line">    context(<span class="string">"when failed to fetch location"</span>) &#123;</span><br><span class="line">        it(<span class="string">"get expected output"</span>) &#123; </span><br><span class="line"><span class="keyword">let</span> isRefreshing = scheduler.createObserver(<span class="type">Bool</span>.<span class="keyword">self</span>)</span><br><span class="line">sut.isPlaying</span><br><span class="line">.drive(isPlaying)</span><br><span class="line">.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">scheduler.createColdObservable([.next(<span class="number">10</span>, ()), .next(<span class="number">20</span>, ()),  .next(<span class="number">30</span>, ())])</span><br><span class="line">          .bind(to: sut.applicationEnteredForeground)</span><br><span class="line">          .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">scheduler.start()</span><br><span class="line"></span><br><span class="line">expect(isRefreshing.events).to(<span class="built_in">equal</span>([</span><br><span class="line">    .next(<span class="number">10</span>, <span class="literal">true</span>),</span><br><span class="line">    .next(<span class="number">20</span>, <span class="literal">true</span>),</span><br><span class="line">    .next(<span class="number">30</span>, <span class="literal">true</span>)</span><br><span class="line">]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上边的测试我们可以发现，我们甚至可以输入一个序列来看输出是什么，这会让我们的测试非常灵活，唯一的缺点就是太长了。</p><h3 id="RxBlocking"><a href="#RxBlocking" class="headerlink" title="RxBlocking"></a>RxBlocking</h3><p>至于 RxBlocking，就有点像把 Rx 这个异步的过程变成同步以方便我们测试，我们也用代码来演示，假设 WeekViewModel 中的 temperature 输出也是一个 PublishSubject，那我们就可以用下边的方法来测试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"its temperature"</span>) &#123;</span><br><span class="line">    context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">        it(<span class="string">"is 12.2 °C - 20.1 °C"</span>) &#123;</span><br><span class="line">            expect(<span class="keyword">try</span>! sut.temperature.toBlocking().first()).to(<span class="built_in">equal</span>(<span class="string">"12.2 °C - 20.1 °C"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以回到上边 WeekViewModel 的测试部分（在 Gearing Up 部分)对比一下，基本上差不多，真的是谁用谁知道。但是任何事情都是有代价的，对于 RxBlocking 来说就是他的局限性：</p><ol><li>RxBlocking 对于无法停止的序列的测试能力很有限，如 BehaviorRelay 这种天生就无法停止的序列就无法用 RxBlocking。</li><li>RxBlocking 会阻塞当前的线程，这个有可能会引起卡死的现象，从而无法进行接下来的单测。</li><li>RxBlocking 无法像 RxTest 对特定时间点的事件进行测试，比如上边 RxTest 的测试中，我们可以很明确的知道在 10、20、30 秒的时候收到了 applicationEnteredForeground，并且我们的输出也是在 10、20、30 秒发出的，但是 RxBlocking 就没有这个能力。</li><li>在这部分刚开始就说了 RxBlocking 是把异步过程强行变成一个同步的过程，所以一些必须要异步触发的 case （比如用一个序列触发另一个序列的这种情况）我们就没法用 RxBlocking。`</li></ol><h3 id="如何做选择"><a href="#如何做选择" class="headerlink" title="如何做选择"></a>如何做选择</h3><blockquote><p>只有小孩子才做选择，大人全都要。</p></blockquote><p>这是如今被用滥的一句梗。但你猜怎么着，用在这还真用对了。</p><p>RxTest 更加全面，可以覆盖大部分测试，而且 TestScheduler 模拟的虚拟时间可以大大缩短测试时间，但是写起来比较长也比较麻烦。相比 RxBlocking 写起来非常简单也直观，但使用场景比较局限。我们何不取长补短，在可以使用 RxBlocking 的时候使用 RxBlocking，而在更复杂的使用场景，尤其是那些需要 timestamp 精准对应的场景使用 RxTest。这样我们就充分利用了两种方式的长处，何乐而不为呢。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这一篇主要讲了关于单测的东西，单测作为 TDD 的根基，是学习 TDD 路上必须要掌握的生存技能。不过对于许多人来说只掌握单测其实就足够了，因为 TDD 只是一种开发模式，而单测才是根本。你也可以在掌握了单测后根据自己或团队的 workflow 来定制属于自己的开发模式。如果你对 TDD 比较好奇的话，也可以继续往下看。</p><p><a href="https://cyberhex.me/2020/07/07/tdd-part-three/">To Be Continued</a>（此处应有专属音乐）</p><div class="note info"><p>相关链接：</p><p><a href="https://github.com/Quick/Quick/tree/master/Documentation" target="_blank" rel="noopener">Quick Documentation</a><br><a href="https://www.raywenderlich.com/135-behavior-driven-testing-tutorial-for-ios-with-quick-nimble#toc-anchor-010" target="_blank" rel="noopener">Behavior-Driven Testing Tutorial for iOS with Quick &amp; Nimble</a><br><a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da" target="_blank" rel="noopener">Test Doubles — Fakes, Mocks and Stubs.</a><br><a href="https://www.mokacoding.com/blog/waituntil-vs-toeventually/" target="_blank" rel="noopener">Nimble: when to use waitUntil or toEventually</a><br><a href="http://rx-marin.com/post/rxblocking-part2/" target="_blank" rel="noopener">Testing with RxBlocking, part 2</a><br><a href="https://www.raywenderlich.com/7408-testing-your-rxswift-code#toc-anchor-005" target="_blank" rel="noopener">Testing Your RxSwift Code</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷二），本系列链表头部请戳 &lt;a href=&quot;https://cyberhex.me/2020/06/14/tdd-part-one/&quot;&gt;A song of TDD and BUG - 前奏曲&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 04</title>
    <link href="http://cyberhex.me/2020/07/05/arts-04/"/>
    <id>http://cyberhex.me/2020/07/05/arts-04/</id>
    <published>2020-07-05T15:36:17.000Z</published>
    <updated>2020-07-05T16:57:40.748Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>前缀树问题（LeetCode 208 中等）</p><p>这个问题也相当于一个比较基础的问题了，它是一些其他题目（比如 Word ladder II 之类的）题目的前置题目，这个题目如果你是想刷算法的话属于必背题目，核心点是在每次插入一个单词的时候更新树的结构，这样的话在下次查找的时候就可以判断是否有这个单词或者是否有以某个单词开头的单词。</p><p>一个比较重要的点就是前缀树和哈希表之间的对比，他们俩在很多时候可以互相替代，前缀树花费的空间更少一些但是单次查询花费的时间更多一点。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>前一阵做单元测试的时候发现一个问题，就是如果想把 UIImage 作为 ViewModel 的输出的时候会有一个问题就是不知道怎么样单测这个 UIImage 的输出，最后无奈只能让 ViewModel 输出 UIImage 的名字，然后在 ViewController 中来进行 UIImage 的初始化。但是昨天看关于单测的东西的时候发现一个很好用的技巧，下次在做单测的时候可以尝试使用了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testImage</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> viewModelImage = viewModel.image</span><br><span class="line"><span class="keyword">let</span> viewModelImageDataReference = viewModelImage.pngData()!</span><br><span class="line"><span class="keyword">let</span> stubImageDataReference = <span class="type">UIImage</span>(named: <span class="string">"test"</span>).pngData()!</span><br><span class="line"><span class="type">XCAssertEqual</span>(viewModelImageDataReference, stubImageDataReference)</span><br><span class="line"><span class="type">XCAssertEqual</span>(viewModelImage.size.width, desiredWidth)</span><br><span class="line"><span class="type">XCAssertEqual</span>(viewModelImage.size.height, desiredHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://cyberhex.me/2020/07/05/unit-test-short-story-01/">尤尼泰斯特 2020 - 回忆篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 03</title>
    <link href="http://cyberhex.me/2020/07/05/arts-03/"/>
    <id>http://cyberhex.me/2020/07/05/arts-03/</id>
    <published>2020-07-05T10:45:12.000Z</published>
    <updated>2020-08-02T11:19:05.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>三角形最小路径之和（LeetCode 120，中等）</p><p>这道题属于动态规划的入门题了，所以感觉给中等完全是给动态规划面子。有两种方法可以做，一种是自底向上，一种是自顶向下。分别对应的是正着想和反向推。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://cyberhex.me/2020/07/07/tdd-part-three/">A song of TDD and BUG - 副歌</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;三角形最小路径之和（LeetCode 120，中等）&lt;/p&gt;
&lt;p&gt;这道题属于动态规
      
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 02</title>
    <link href="http://cyberhex.me/2020/07/05/arts-02/"/>
    <id>http://cyberhex.me/2020/07/05/arts-02/</id>
    <published>2020-07-05T09:41:11.000Z</published>
    <updated>2020-08-02T11:17:57.884Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>有效的括号（Leetcode 20，简单）</p><p>偷个懒做一道简单的题。这道题是写在脸上的用 stack 来做，而且属于实现比较简单的那种（写计算器能把你写吐血）。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://cyberhex.me/2020/07/07/tdd-part-two/">A song of TDD and BUG - 主歌</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 前奏曲</title>
    <link href="http://cyberhex.me/2020/06/14/tdd-part-one/"/>
    <id>http://cyberhex.me/2020/06/14/tdd-part-one/</id>
    <published>2020-06-14T09:41:34.000Z</published>
    <updated>2020-07-29T13:37:01.280Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷一）<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是最好的时代，TDD 的出现终结了 BUG 横行的蛮荒，从此 Coding 世界进入了秩序与光明；这也是最坏的时代，历史的包袱，无尽的重构，博弈与妥协充斥在每个角落。从电脑和编程出现之初 Bug 就如影随形，那只飞到 Mark II 上的 Bug 穿越了大半个世纪，仍是程序员们在梦中惊醒，在镜前流泪的主要原因。那 Bug 为什么会出现？有没可能消除 Bug？ 这是个哲学问题。</p><h2 id="Bug的相对性原理"><a href="#Bug的相对性原理" class="headerlink" title="Bug的相对性原理"></a>Bug的相对性原理</h2><p>有人说 Bug 是一个 Human Error，是可以通过一定的约定，准则和谨慎去避免的。的确, Bug 的多少很大程度上是程序员的谨慎程度来决定的。但是，我先把我的结论放在这， Bug 是无法避免的，也就是说他是一个在排除了人为错误之外的系统性的存在。</p><p>这听起来很像给自己开脱（其实就是给自己开脱），但是我是有理（狡）论（辨）支持的。比如之前有人提出来过抽象漏洞定律来解释这个问题，但是这个太笼统，听起来也太抽象，我想用自己的理解来解释一下。首先我们需要定义 Bug 是什么，维基百科中 Bug 的定义是程序错误。我们在这给它一个更明确，更有意义的定义，就是： Bug 是程序中与预期情况表现不符合的逻辑。比如：产品让我点击购买键下单，我写成了点击购买键弹窗嘲讽用户买不起。这就是一个 Bug。从上边的例子里我们可以发现，之前定义中的预期是需要参照物的，而这个参照物是什么，这才是真正的 tricky part。如果这个参照物值得是所有人的预期表现，那这个问题就好回答了，每个人或者说至少有一些的对不同同一个功能有不同的预期，这样的话在一些人看来正常的代码，在另一些人看来就是 Bug，这就是 Bug 的相对性。而如果这个参照物是指的产品需求，这可能就需要一番解释了。</p><p>在这里我想引入两个概念：需求的时间局部绝对正确性和需求的绝对进化性。听起来很 fancy，其实很简单（你不小心发现了程序员术语的真相）。需求的时间局部绝对正确性是指一个需求在下一次需求到来之前是具有绝对的权威性的，需求的绝对进化性是指两个相邻需求之间是至少有一处不同的。了解了这两个概念，后边的推理就简单多了。使用数学归纳法，假设上一个代码和需求是完全符合的，在下一个需求到来的时候，根据需求的时间局部绝对正确性，这时候具有绝对正确性的需求是新来的需求，而又由于需求的绝对进化性，新需求和上一个需求之间至少有一处不同，也就是现在的代码至少有一处跟新需求不同，根据 Bug 的定义，也就是至少有一个 Bug。有人会说，那假设我不变需求不就是不会有这种 Bug 了吗，可别忘了，从无到有也是一种情况。这个本来就是一个很有争议的问题，有什么想法也可以在评论区一起讨论。</p><h2 id="程序员的千层饼理论"><a href="#程序员的千层饼理论" class="headerlink" title="程序员的千层饼理论"></a>程序员的千层饼理论</h2><p>听了我瞎扯了这么久，你可能在想这人到底想说个啥。我其实想表达的是 Bug 如风，常伴吾身，我们要学会去与之共存。但是与之同存并不是对其容忍（skr），我们的先辈们披荆斩棘为我们探索出了很多路，其中一条非常亮眼的就叫单元测试。作为程序员对单测有一定了解或者至少有所耳闻，但大部分对自己对于单测的认知多多少少都有一些障碍。在这里我就想借鉴一下 LOL 直播界的哲学家大司马老师的千层饼理论来阐述我的观点。对于单测，很多程序员都认为自己看到了第五层，觉得自己在第二层，其实自己是在第一层，像我这种马虎点的甚至都在地下一层。那这里边的第几层分别代表什么呢。第五层代表不写任何种类的测试就能做到杜绝人为的 Bug，第二层代表会写单测就是懒得写而已，第一层代表并不会写单测，而地下一层代表不但不会写单测而且只会写 Bug。你品，你细品，自己属于第几层。</p><h2 id="你不愿写单测的原因"><a href="#你不愿写单测的原因" class="headerlink" title="你不愿写单测的原因"></a>你不愿写单测的原因</h2><p>不愿写单测的原因有千千万，但是大体可以分为以下三类：</p><ol><li>业务都写不完，哪来的时间弄这破玩意</li><li>已经有测试了，没有必要浪费时间去写单测，我还要追求诗和远方</li><li>业务逻辑太简单了，我就是人形单测</li></ol><h2 id="单测的重要性"><a href="#单测的重要性" class="headerlink" title="单测的重要性"></a>单测的重要性</h2><p>其实我之前跟其他人一样也会有很多的顾虑（其实是懒），之前看一些教程如果碰到关于单测的部分我都是跳过或者边看视频边“学”完，但是在工（被）作（迫）需（无）要（奈）之下我开始接触关于单测和 TDD 的东西，现在可以说是单测最忠实的追随者了。现在我就替你来一一打消上边提到的所有顾虑。</p><ol><li>关于第一点顾虑：没有时间。只要你跟着这个系列教程，会让你对单测有更深的了解，至少会带你入门并且写出第一个单测，你就想像我这么懒的人都能学会，你凭什么学不会。</li><li>关于第二点顾虑，我主要想分成两部分来分析 - “有测试” 和 “浪费时间”：<ul><li>有测试：团队内的 QA 所做的测试都是黑盒测试，也就是他们只能告诉你现象，更好一点告诉你复现的具体步骤，有经验的测试可能会告诉你他们的猜测。但是猜测毕竟只是猜测，你还是需要一步一步去调试，去寻找 Bug 的根源。但是如果是单测跑失败了，你只需要看一眼单测的名字，就可以基本上定位到问题所在了。</li><li>浪费时间：上一点已经有一点涉及到节省时间了，但是这还不够。我们做一个项目，一般都不是只做一版不需要迭代，也免不了重构。只要是需要迭代或者重构，就有单测发挥优势的机会，因为在这些过程中所产生的副作用，比如对之前逻辑的影响，都会由之前的单测来保证，这会很大程度上节省我们排查旧逻辑的时间。        </li></ul></li><li>关于第三点顾虑，业务逻辑简单是相对的，对于你来说，旧逻辑都是你写的或者是你维护的，但是对于新来的同事，他们可能就会一头雾水，需要一段时间去了解业务，但是如果有单测（BDD 更好，这里挖个坑，以后填），通过看单测，他/她就会对业务有个大概了解，对于之后的工作有很大的帮助。</li></ol><h2 id="什么是-TDD"><a href="#什么是-TDD" class="headerlink" title="什么是 TDD"></a>什么是 TDD</h2><p>再声明一遍，不是 PDD，不是 SSD，更不是 PTSD。下边我们有请开发模式界最耀眼的新星，不健壮代码的救世主，莫得感情的 Bug 收割机器 - T·听起来就很炫酷·DD。TDD 的全称是 Test-Driven Development，翻译过来就是测试驱动开发。它是敏捷开发的一项实践和技术，它背后的行为哲学就是以测试为导向进行项目的开发。</p><p>它有四个步骤：</p><ol><li>写一个失败的单元测试</li><li>完善代码让测试通过</li><li>重构</li><li>重复上述步骤到天荒地老</li></ol><p>看起来貌似很简单的样子，但其实里边另有乾坤，后边会进行进一步的解释。</p><h2 id="赛博朋克演示法"><a href="#赛博朋克演示法" class="headerlink" title="赛博朋克演示法"></a>赛博朋克演示法</h2><p>本系列我会继续使用我最喜欢的赛博朋克演示法，那有同学就要问了，什么是赛博朋克演示法呢？其实大家都在写博客或者做分享的时候用到过，只不过这个方法被我冠名成赛博朋克演示法，我还没有看到其他人这么叫过，所以算原创吧（小得意一下）。</p><p>众所周知，所谓赛博朋克就是高科技，低生活。那套用在这里就是用一个特别傻的项目去演示一个特别 fancy 的概念。所以贯穿整个系列我都会用一个天气的项目叫做 <a href="https://github.com/quintessencegpy/Rainstorm" target="_blank" rel="noopener">Rainstorm</a> 来展示单测和 TDD 的概念，这个项目不是我的原创，是我在学习 MVVM 的时候跟着 <a href="https://cocoacasts.com/" target="_blank" rel="noopener">cococast.com</a> 一起做的，这个不是广告，只是既然用了人家的东西，总得给人家一个名分，嗯嗯。</p><p>如果你对我说的这些都感兴趣，那就跟着我的节奏一起摇摆（不好意思，走错片场了），跟着我的步伐一起深入了解 TDD，欢迎观看下一集 <a href="https://cyberhex.me/2020/07/07/tdd-part-two/">A song of TDD and BUG - 主歌</a>。</p><div class="note info"><p>相关链接：</p><p><a href="https://kknews.cc/zh-hk/code/qx5639g.html" target="_blank" rel="noopener">為什麼任何系統都會存在Bug？什麼是抽象漏洞定律？</a><br><a href="https://blog.gurock.com/unit-testing-tdd-bdd/?utm_source=adwords&amp;utm_medium=cpc&amp;utm_campaign=asia_afr_ams_en_dsa&amp;utm_content=&amp;creative=302597526479&amp;keyword=&amp;matchtype=b&amp;network=g&amp;device=c&amp;gclid=CjwKCAjwmMX4BRAAEiwA-zM4JryMT8iAqgeNEpB6mdo1aCOXYdR-EOIEADy8R1eG20r5vvgv7lelfhoCDDYQAvD_BwE" target="_blank" rel="noopener">Unit Testing, TDD, and BDD, Oh My. Your Guide to Different Unit Testing Techniques</a><br><a href="http://www.51testing.com/html/00/n-3724000.html" target="_blank" rel="noopener">论单元测试的重要性</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷一）&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 01</title>
    <link href="http://cyberhex.me/2020/06/14/arts-01/"/>
    <id>http://cyberhex.me/2020/06/14/arts-01/</id>
    <published>2020-06-14T09:41:11.000Z</published>
    <updated>2020-07-05T16:57:43.466Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>N 皇后问题（LeetCode 51 困难）</p><p>这个题目也算是 DFS 算法中经典的经典，所以这道题目的结构也是遵循递归的几大步骤（recursion terminator，current level logic，drill down，reverse state if needed），只不过这道题目需要多考虑的是怎么剪枝，也就是如果提前发现本次递归是一个无效的递归就提前终止。我的做法是用了三个 set 来记录当前的位置是否有效，我看讨论区还有一种用位运算来处理的，看起来很 fancy，但是没有仔细去研究，有时间需要好好看一下。</p><p>DFS 一直感觉有一点烧脑，尤其是如果做人肉递归的情况下，以后要养成避免人肉递归的习惯。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>最近一直在看 Raywenderlich 的 RxSwift 的书，已经看到了第 24 章（总共 25 章 fighting！），感觉收获很大，好好反思了之前对于 RxSwift 的用法，觉得有很多不合理的地方，而且也有了一些在工作上该如何使用的思考，顺便思考了之前项目中的架构的不足，由于最近开始折腾单测的问题才发现之前有很多不合理的地方，在之后的重构中要更加注意。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本来以为这周的 tips 可能要鸽了，但是在打卡前的最后几个小时发现了一个看起来很有意思的小技巧，让我这个强迫症眼前一亮。<br>在 MVVM 中因为每一个 ViewController 都会有一个 ViewModel，所以之前我在创建 ViewController 的时候有两种方法，一种是用 Initializer Injection，也就是把 ViewModel 作为 ViewController的 Init 方法的参数，另一种就是把 ViewModel 设为一个 Optional 的 internal 的变量，在初始化 ViewController 之后把 ViewModel 赋值进去。但感觉这两种方法都有一点不符合我的习惯，第一种需要加一个没用的 required 的 initializer，第二种需要在初始化之后赋值（有可能会忘）。今天发现一种使用工厂方法来创建 ViewController 的套路，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> viewModel: <span class="type">ViewModel</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(withViewModel viewModel: ViewModel)</span></span> -&gt; <span class="type">ViewController</span> &#123;</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">ViewController</span>()</span><br><span class="line">vc.viewModel = viewModel</span><br><span class="line"><span class="keyword">return</span> vc</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://cyberhex.me/2020/04/26/coodinator-pattern/">都是 Apple 惹的祸 - Coordinator Pattern 的前世今生</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>都是 Apple 惹的祸 - Coordinator Pattern 的前世今生</title>
    <link href="http://cyberhex.me/2020/04/26/coodinator-pattern/"/>
    <id>http://cyberhex.me/2020/04/26/coodinator-pattern/</id>
    <published>2020-04-26T09:39:41.000Z</published>
    <updated>2020-06-14T11:02:17.519Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在学习 Coordinator Pattern 是的心得。<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近工作中需要对一个升级 B 端的项目，本来只是更新 UI，对 H5 进行支持的简单工作，但是我灵机一动（用大脑一抽可能更好一点），决定对项目进行一次重构，目标 MVVM-C。对于 MVVM 可能大家了解的比较多，但是后边那个小 C 是什么可能有些小朋友并不是特别清楚。这种时候，从小就开始训练的阅读理解能力就派上用场了，看一眼文章题目你就知道这个 C 代表什么了。什么？ CyberHex？虽然我很开心，但是我替你们的语文老师伤心三秒，1，2，3，好了。其他人应该都猜对了，对！就是 Coordinator。那到底什么 Coordinator 的设计模式？它是怎么产生的？它解决了什么痛点？接下来我就带大家走进 Coordinator 的内心，从而对它有一个更深的了解。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从文章题目“都是 Apple 惹的祸”你可能已经看到了一些问题的端倪，没错，Coordinator Pattern 的出现就是为了弥补苹果在设计 UIKit 的时候的一些疏忽（不知道是有意还是无意的）。多年前一个风雨交加，电闪雷鸣的夜晚，UIKit 带着全村人的希望诞生了，谁都不知道它的出现将改变移动端的整个未来，更没有人想到的是，在风光无限的背后，是一个致命的（？）生理缺陷，而这个缺陷也将为它带来巨大的危机。而就是到了那时，一个叫 Coordinator 的盖世英雄将踩着七色云彩来解救它。好了，不瞎扯了，我觉得我的水平不去 UC 当编辑真的是屈才了。 其实在很早的时候就有人发现了 UIKit 的这个缺陷并试图去解决它，最早有 <a href="https://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">Soroush Khanlou</a> 的尝试，到现在 Coordinator 已经是一个比较成熟的 iOS 设计模式了，并且和 MVVM 经常同框出镜，人们称这对好基友组合为 MVVM-C。现在就要有人说了，卖了这么多关子，到底它解决了哪些问题。别着急，接下来胡扯环节结束，上干货。</p><h2 id="UIKit-的内在问题和-Coordinator-的解决方法"><a href="#UIKit-的内在问题和-Coordinator-的解决方法" class="headerlink" title="UIKit 的内在问题和 Coordinator 的解决方法"></a>UIKit 的内在问题和 Coordinator 的解决方法</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在学习 Coordinator Pattern 是的心得。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://cyberhex.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://cyberhex.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Design Pattern" scheme="http://cyberhex.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>优化图片</title>
    <link href="http://cyberhex.me/2019/06/26/optimizing-images/"/>
    <id>http://cyberhex.me/2019/06/26/optimizing-images/</id>
    <published>2019-06-25T16:39:37.106Z</published>
    <updated>2020-06-14T11:02:02.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jordan Morgan，<a href="https://www.swiftjectivec.com/optimizing-images/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-11<br>译者：CyberHex；</p></blockquote><p>人们常说你手里的相机就是最好的那个。如果俗语能说明一些问题的话，那么毫无疑问，iPhone 完全就是这个星球上最重要的相机。而且整个行业也证明了这件事。</p><p>出去度假了？不给你的 Instagram 上传几张照片顺便在手机里存几张备用的都不太可能。</p><p>又出了个大新闻？翻翻微博查看有关这个事件的图片就可以实时掌握有哪些渠道在播报这件事。</p><p>例子数不胜数。</p><p>但是尽管图片无处不在，想用一种既能保持高性能又不消耗很多内存的方式来展示这些图片还真得多费点劲。只要了解了 UIKit 中发生了什么，并且理解了它如何处理图片，我们就可以节省一大笔内存同时还能免去想砸键盘的冲动。</p><h2 id="讲一点理论"><a href="#讲一点理论" class="headerlink" title="讲一点理论"></a>讲一点理论</h2><p>先出一个脑筋急转弯：下面这张我女儿非常潮的照片有 266KB，猜一下它在 iOS 应用中需要占多少内存？</p><p><img src="https://www.swiftjectivec.com/assets/images/baylor.jpg" alt="Photo of dauther"></p><p>剧透警告：不是 266k，也不是 2.66M，而是 14M。</p><p>怎么会这样？</p><p>iOS 在得出内存使用的时候基于的是图片的维度，而图片真正的大小跟内存没有几毛钱关系。这张图片的维度是 1718 像素宽，2048像素高。假设每个像素占用四个字节内存：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1718</span> * <span class="number">2048</span> * <span class="number">4</span> / <span class="number">1024</span> / <span class="number">1024</span> = 大约 <span class="number">13.42</span> <span class="type">MB</span></span><br></pre></td></tr></table></figure><p>假设你有一个包含一堆用户的 table view，每一行都在左上角用如今最流行的圆形来展示他们的头像。如果你觉得这没什么，因为这些图片已经用 ImageOptim 或者相似的东西压缩过了，那你就大错特错了。假设每个图片是 256x256 的话，这样还是会占掉不少的内存。</p><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>通过上边的例子，我们可以得出：了解渲染图片的机制也非常重要。当你载入一个图片，会有下边三个步骤：</p><p>1.载入：iOS 把压缩后的图片（在我们的例子中 266KB）放入内存中。这一步中并没有什么需要特别注意的。<br>2.解码：接下来，iOS 把图片转化为 GPU 可以理解和读取的形式。这一步中图片已经不是压缩状态了，现在就到了我们上边说的 14MB。<br>3.渲染：就像步骤名所说的一样，图片数据已经能够以任意形式被渲染到屏幕上，就算只是一个 60*60 那么小的 image view。</p><p>解码过程算一个比较重要的阶段。在这个过程中 iOS 会创建一个缓存区（准确的来说是一个图片缓存区），它是图片在内存中的表现形式。这就很好的解释了为啥这个缓冲区的大小本质上是和图片的面积而非文件大小挂钩的。从而也清楚的描绘了在计算图片的内存消耗时为什么图片的维度这么重要。</p><p>对于 UIImage 来说，当我们塞给他的不论是从网络请求或者是其他途径里得到的图片数据，它都会把这些数据缓存解析为数据中所要求的任何压缩形式（比如 PNG 或者 JPG）。但是，这些数据其实还是会继续存在，因为渲染不是一个只会进行一次的操作，所以 UIImage 会把图片缓存保存下来，确保它只被解析一次。</p><p>现在我们发散一下思维：一个可以适用于任何 iOS 应用的完整缓存区就是它的帧缓存区。当你的应用要出现在屏幕上时，帧缓存区把它真正的显示出来，因为缓存区里有需要被显示出来内容的渲染结果。任何 iOS 设备的显示硬件都可以利用这些像素信息把这些像素展现在屏幕上。</p><p>在这种情况下，时长就会影响结果。想得到 60 帧每秒的行云流水般的滑动，帧缓存区就需要让 UIKit 渲染应用的窗口，并且需要当子视图的信息有变化时（比如给 image view 添加图片），所有子视图都加到窗口上边。如果这一步完成的太慢的话，就会丢帧。</p><blockquote><p>你觉得六十分之一秒已经很短了？想象一下，有 Pro Motion 技术的设备会把这个数字提到一百二十分之一秒。</p></blockquote><h2 id="尺寸很重要"><a href="#尺寸很重要" class="headerlink" title="尺寸很重要"></a>尺寸很重要</h2><p>我们可以很容易的对这个过程和过程中的内存使用进行可视化。就用之前我女儿的那张照片，我创建了一个很简单的应用，里边有一个 image view 来展示这张照片：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">NSURL</span>(fileURLWithPath: filePath)</span><br><span class="line"><span class="keyword">let</span> fileImage = <span class="type">UIImage</span>(contentsOfFile: filePath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image view</span></span><br><span class="line"><span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(image: fileImage)</span><br><span class="line">imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">imageView.contentMode = .scaleAspectFit</span><br><span class="line">imageView.widthAnchor.constraint(equalToConstant: <span class="number">300</span>).isActive = <span class="literal">true</span></span><br><span class="line">imageView.heightAnchor.constraint(equalToConstant: <span class="number">400</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">view.addSubview(imageView)</span><br><span class="line">imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>在实际工作中不要使用强行解包，这个例子比较简单，所以才小用一下。</p></blockquote><p>我们会得到如下结果：</p><p><img src="https://www.swiftjectivec.com/assets/images/baylorPhone.jpg" alt="Photo of dauther"></p><p>迅速去 LLDB 上瞄一眼就可以发现，就算我们用一个更小的 image view 来展示这张图，它的维度还是原来那样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="type">UIImage</span>: <span class="number">0x600003d41a40</span>&gt;, &#123;<span class="number">1718</span>, <span class="number">2048</span>&#125;</span><br></pre></td></tr></table></figure><p>注意哟，这里可是用点来表示的。也就是说，如果我在用一个 3x 或者是 2x 的设备，有可能还会得到一个是这个倍数的数字。接下来我们转战去 vmmap，看我们能不能确认这张图用了 14MB 的内存：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmmap --summary baylor.memgraph</span><br></pre></td></tr></table></figure><p>下边几项数据比较亮眼：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Physical</span> footprint:         <span class="number">69</span>.5M</span><br><span class="line"><span class="type">Physical</span> footprint (peak):  <span class="number">69</span>.7M</span><br></pre></td></tr></table></figure><p>现在有将近 70M 的内存使用，也给了我们一个重构代码的基准。如果我们集中再看看我们图片的内存消耗：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmmap --summary baylor.memgraph | grep <span class="string">"Image IO"</span></span><br><span class="line"></span><br><span class="line"><span class="type">Image</span> <span class="type">IO</span>  <span class="number">13</span>.4M   <span class="number">13</span>.4M   <span class="number">13</span>.4M    0K  0K  0K   0K  <span class="number">2</span> </span><br></pre></td></tr></table></figure><p>啊嘞嘞，内存里有大约 14MB 的脏内存。这跟我们当时估算的图片的大小一样。为了充实论点，下边我给出了一张截图可以清晰的看出每一行的消耗，因为这是使用 grep 查到的。</p><p><img src="https://www.swiftjectivec.com/assets/images/vmmap.jpg" alt="Snapshot of grepin"></p><p>所以很明显，现在我们在一个 300 x 400 的 image view 上使用了原图所占的内存大小。图片的大小很重要，但是这不是唯一影响内存消耗的因素。</p><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><p>你所请求使用的一部分内存是由另一个重要因素色域所决定的。在上边的例子中，我们做了一个在大部分 iPhone 中并不成立的假设，就是图片使用的是 sRGB 格式。一个像素点有4个字节是因为给了红、蓝、绿和透明度各一个字节。</p><p>如果你用一个支持非常广色域的手机（不如 iPhone 8P 或者 iPhone X）来拍照，你很有可能会使用双倍的内存。当然，倒过来也是对的。Metal 可以使用 Alpha 8 的格式，这种格式就跟它名字所暗示的那样，只用一个维度（透明度）。</p><p>这里边有好多需要考虑和操作的东西。这就是为什么我们要用 <a href="https://www.swiftjectivec.com/uigraphicsimagerenderer/" target="_blank" rel="noopener">UIGraphicsImageRender</a> 而不是用 UIGraphicsBeginImageContextWithOptions，后者总是会使用 sRGB，也就是说在你想用<a href="https://instagram-engineering.com/bringing-wide-color-to-instagram-5a5481802d7d" target="_blank" rel="noopener">更广的色域</a>的时候无法使用它们，或者在你想选择较小色域的时候没法节省内存。在 iOS 12 以后，UIGraphicsImageRender 会帮你选择最合适的那一个。</p><p>这里再提一嘴，免得过会再忘了，很多我们截的图片其实并不是拍摄类型，而仅仅是简单的绘图操作。并不是说想重提我前一阵写过的东西，但是以防你之前没看过：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> circleSize = <span class="type">CGSize</span>(width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UIGraphicsBeginImageContextWithOptions</span>(circleSize, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画个圈圈</span></span><br><span class="line"><span class="keyword">let</span> ctx = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line"><span class="type">UIColor</span>.red.setFill()</span><br><span class="line">ctx.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">ctx.addEllipse(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line">ctx.drawPath(using: .fill)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circleImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line"><span class="type">UIGraphicsEndImageContext</span>()</span><br></pre></td></tr></table></figure><p> 上边这个圆形图像使用的是每个像素 4 个字节的格式。如果使用 UIGraphicsImageRender 的话，它会自动帮你选择最合适的格式来渲染，这样你在全部选用每像素 1 个字节的格式的情况下最多能节省 75% 的内存。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> circleSize = <span class="type">CGSize</span>(width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"><span class="keyword">let</span> renderer = <span class="type">UIGraphicsImageRenderer</span>(bounds: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circleImage = renderer.image&#123; ctx <span class="keyword">in</span></span><br><span class="line">    <span class="type">UIColor</span>.red.setFill()</span><br><span class="line">    ctx.cgContext.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">    ctx.cgContext.addEllipse(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line">    ctx.cgContext.drawPath(using: .fill)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="缩放-VS-降采样"><a href="#缩放-VS-降采样" class="headerlink" title="缩放 VS. 降采样"></a>缩放 VS. 降采样</h2><p>先把刚才那个简单的绘图的例子放在一边，其实大部分与图片相关会影响内存使用的问题都源自于那些现实生活中人们摄影的照片。包括用 portraits 和 landscape 拍出来的照片和一些其他的照片。</p><p>这也证明了为什么一些程序猿们会觉得用 UIImageView 进行图片缩放就够使了。但是 UIImageView 的问题一般不是因为上边所罗列出来的原因，而且根据苹果大神 Kyle Howarth 的说法，它性能不好是因为内部坐标的转换。</p><p>在这种情况下，UIImage 会影响效率的一个主要原因是它会按照我们之前在渲染管线中讨论过的那样把原始图片压缩进内存中。而在理想情况下，我们需要想个办法来减少图片缓存区的大小。</p><p>庆幸的是，只用被缩放后图片所消耗的内存来调整图片大小是有可能的，这也是为什么好多人会以为这个是在缩放图片时的默认行为。然而实际情况并不是这样。</p><p>我们现在尝试换成底层的 API 来进行缩放：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(url, <span class="literal">nil</span>)!</span><br><span class="line"><span class="keyword">let</span> options: [<span class="type">NSString</span>:<span class="type">Any</span>] = [kCGImageSourceThumbnailMaxPixelSize:<span class="number">400</span>,</span><br><span class="line">                            kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> scaledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options <span class="keyword">as</span> <span class="type">CFDictionary</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(image: <span class="type">UIImage</span>(cgImage: scaledImage))</span><br><span class="line">    </span><br><span class="line">    imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    imageView.contentMode = .scaleAspectFit</span><br><span class="line">    imageView.widthAnchor.constraint(equalToConstant: <span class="number">300</span>).isActive = <span class="literal">true</span></span><br><span class="line">    imageView.heightAnchor.constraint(equalToConstant: <span class="number">400</span>).isActive = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    view.addSubview(imageView)</span><br><span class="line">    imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">    imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>我们会得到和以前一样的结果。但是这次，我们用的是听起来就有逼格的 CGImageSourceCreateThumbnailAtIndex() 而不是简单得把图片丢给 image view 来处理。又一次，我们这次优化是否有效的真相就藏在 vmmap 中（为了简便就做了四舍五入）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmmap -summary baylorOptimized.memgraph</span><br><span class="line"></span><br><span class="line"><span class="type">Physical</span> footprint:         <span class="number">56</span>.3M</span><br><span class="line"><span class="type">Physical</span> footprint (peak):  <span class="number">56</span>.7M</span><br></pre></td></tr></table></figure> <p>我们已经能看到省了不少内存。如果和之前的 69.5MB 相比，56.3MB 足足少了 13.2MB。这是一笔很大的节省，几乎相当于整张图片的消耗。</p><p>接下来，有很多选择能让你在不同的情况下去做尝试。在 WWDC 18的会议 219 “图像和图形的最好实践”中，苹果公司的工程师 Kyle Sluder 给我们展示了一个非常有趣的方法 - 使用 kCGImageSourceShouldCacheImmediately 标识位来控制解析过程：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downsampleImage</span><span class="params">(at URL:NSURL, maxSize:Float)</span></span> -&gt; <span class="type">UIImage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sourceOptions = [kCGImageSourceShouldCache:<span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> source = <span class="type">CGImageSourceCreateWithURL</span>(<span class="type">URL</span> <span class="keyword">as</span> <span class="type">CFURL</span>, sourceOptions)!</span><br><span class="line">    <span class="keyword">let</span> downsampleOptions = [kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">                            kCGImageSourceThumbnailMaxPixelSize:maxSize</span><br><span class="line">                            kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">                            kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">                            ] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> downsampledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(source, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>在上边的函数中，Core Graphics 会在你想要缩略图的特定时刻才会进行解析。 注意要像我们之前的那两个例子中一样加入 kCGImageSourceCreateThumbnailMaxPixelSize 的变量，因为如果你不加的话，你得到的缩略图会和原图一样大。文档中这样说：</p><blockquote><p>“如果不指定像素大小上限的话，缩略图就会跟原图一样大，你肯定不想看到这样的结果”</p></blockquote><p>所以发生了什么？简单的说，就是我们通过在缩放阶段使用缩略图从而创建了一个比以前小很多的解析图片缓存区。现在回头想想我们的渲染管线，第一步（载入）中我们丢给 UIImage 一个只包含我们要展示的图片的图片缓存区，而不是传入相当于整个图片维度的缓存区让它去解析。</p><p>如果你想用一秒钟来读完这篇文章的话就记住一句话。有机会的话一定要用降采样而不是使用 UIImage 的缩放来处理图片。</p><h2 id="彩蛋时间"><a href="#彩蛋时间" class="headerlink" title="彩蛋时间"></a>彩蛋时间</h2><p>我个人喜欢把上边的方法和 iOS 11 以后引入的 <a href="https://developer.apple.com/documentation/uikit/uitableviewdatasourceprefetching?language=swift" target="_blank" rel="noopener">prefetch API</a> 放在一起用。要记住，因为我们要在 table view 或者 collection view 显示 cell 之前解析图片，所以我们很容易不知不觉的就引入 CPU 峰值。</p><p>因为 iOS 非常擅长在有稳定电量需求的情况下管理电量使用，但是在这种情况下电量需求是断断续续的，所以是时候让我们自己写的队列来展示真正的技术了。这样做也会把解析过程放在背景线程中，一石二鸟啊。</p><p>捂上你的双眼，别被下边我的小项目里的 OC 的代码亮瞎了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用你自己写的队列而不是 global async 可以避免线程崩溃</span></span><br><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView prefetchRowsAtIndexPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downsampledImage != <span class="literal">nil</span> || </span><br><span class="line">        <span class="keyword">self</span>.listItem.mediaAssetData == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *mediaIndexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="number">0</span></span><br><span class="line">                                                     inSection:SECTION_MEDIA];</span><br><span class="line">    <span class="keyword">if</span> ([indexPaths containsObject:mediaIndexPath])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> scale = tableView.traitCollection.displayScale;</span><br><span class="line">        <span class="built_in">CGFloat</span> maxPixelSize = (tableView.width - SSSpacingJumboMargin) * scale;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.downsampleQueue, ^&#123;</span><br><span class="line">            <span class="comment">// Downsample</span></span><br><span class="line">            <span class="keyword">self</span>.downsampledImage = [<span class="built_in">UIImage</span> downsampledImageFromData:<span class="keyword">self</span>.listItem.mediaAssetData</span><br><span class="line">                               scale:scale</span><br><span class="line">                        maxPixelSize:maxPixelSize];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^ &#123;</span><br><span class="line">                <span class="keyword">self</span>.listItem.downsampledMediaImage = <span class="keyword">self</span>.downsampledImage;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 在有很多图片 asset 的情况下，记得一定要使用 Asset Catalog，因为它早已经帮你管理好了缓存区的大小（还有很多其他的东西）。</p></blockquote><p>如果想在成为内存和图片的一等公民这个话题中得到更多的启发，记得一定要看 WWDC 18 中这些有含金量的会议：</p><p>· <a href="https://developer.apple.com/videos/play/wwdc2018/416/?time=1074" target="_blank" rel="noopener">深入了解 iOS 内存</a><br>· <a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="noopener">图像和图形的最佳实践</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你不知道的就是不知道。要知道作为码农，你走上的的是一个每天需要跑 10000 公里才能赶得上潮流的不归路。换句话说就是，有成千上万的你没接触过的 API，框架，模式或者优化方式。</p><p>这也适用在图片处理上。大部分时候你都会用一堆漂亮的像素点来初始化 UIImageView 就哦了。我理解，摩尔定律嘛，反正这些手机都有几个 G 的内存。况且，我们就用了那种不到 100k 内存的电脑就把人给送上了月球了。</p><p>但是俗话说得好，常在河边走哪有不湿鞋。不要让内存垃圾成为系统给你罚款的理由，因为现在随便一张自拍都得要一个 G 的内存。但愿这些知识和套路能减少你看崩溃日志的次数。</p><p>请听下回分解✌️。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Jordan Morgan，&lt;a href=&quot;https://www.swiftjectivec.com/optimizing-images/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：201
      
    
    </summary>
    
      <category term="翻译" scheme="http://cyberhex.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Swift" scheme="http://cyberhex.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Design Pattern" scheme="http://cyberhex.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 View Controller Containment</title>
    <link href="http://cyberhex.me/2019/06/21/viewcontroller-containment/"/>
    <id>http://cyberhex.me/2019/06/21/viewcontroller-containment/</id>
    <published>2019-06-21T13:59:24.781Z</published>
    <updated>2020-06-14T11:01:32.489Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在工作过程中如何利用 View Controller Containment 来重构 UI<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道你有没有经历过这样的情况，一个页面中有很多的 View，但各个 View 之间有明显的层级关系，这个时候一种可行的做法是把一系列相关联的 View 归到一个父亲 View 中。 但这种做法会有有一些其他的问题， 比如会让 View Controller 或者 View Model 比较大， 甚至有时候不得不把逻辑写在 View 里边。那么有没有一个既可以解决问题， 又不会引入更多棘手的问题的方法吗？ 问得好！ 如果你心里真的这个问题，那说明你一定是在质疑我写这篇分享的初衷。 不过别担心，看到最后我保证你一定会有所收获的。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>铺垫了这么多，你可能会想: View Controller Containment 到底是什么个玩意，从来没听说过，确定会有人用这个吗？ 但是接下来我会打消你的疑虑，因为苹果自己就在设计 UINavigationController 和 UITabBarController 利用了这种模式。在UINavigationController 和 UITabBarController 中你都可以塞入自定义的控制器， 只不过他们控制这些控制器的形式不同（一个是堆叠，一个是平行）。</p><p>那么 View Controller Containment 到底是什么呢？ 其实非常简单，就是把一个控制器当作容器，只不过这个控制器比较特别一点，它不止能控制 View， 还可以控制在它里边的控制器。 这种模式中，父控制器只需要来管理和安排子控制器 View 的布局和大小，而子控制器负责它自己内部各个 View 的布局和大小。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>听起来如此简单的改变，能给我们带来什么呢？这就需要讨论一下 View Controller Containment 的优点。</p><h3 id="可复用性"><a href="#可复用性" class="headerlink" title="可复用性"></a>可复用性</h3><p>利用 View Controller Containment 一个很大的优点就是可复用性，比如上边提到的苹果自带 SDK 中的 UINavigationController 和 UITabBarController 都有极大的可复用性，基本上在每个项目中都会用到。在项目中我们有时候也会碰到一些情况会有需要复用 Root View Controller 的情况。比如我在最近的一个项目中，会碰到有在同一个页面有三个区块，并且在项目不同的地方会对它们做相同的布局甚至动画。所以这种情况下抽出来一个可复用的 Root View Controller 就会极大的提高工作效率。</p><h3 id="逻辑分离"><a href="#逻辑分离" class="headerlink" title="逻辑分离"></a>逻辑分离</h3><p>对于一些比较复杂的页面，分出来不同的控制器，让子控制器来控制各自的逻辑，这样会让整个 UI 的结构更加清晰，每一个控制器的职责更加明确，会有更强的拓展性，以后如果想加入新的功能或者动画，我们只需要加入新的控制器，最多再加几个回调和代理，并不需要对原来的 UI 结构有很大的改动。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>拿我现在做的一个直播页边来举例，里边有比较明显的三个区块，一个课件区，一个视频区，一个是讨论区。每个区块上边还有一些相关的 View。 所以我觉得可以用 View Controller Containment 来实现。 用一个 MasterViewController 来管理这三个区域。 这三个区域也是不同的子控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoViewController</span>: <span class="title">UIViewController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeynoteViewController</span>: <span class="title">UIViewController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatViewController</span>: <span class="title">UIViewController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterViewControlller</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> videoViewController: <span class="type">VideoViewController</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">VideoViewController</span>()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> keynoteViewController: <span class="type">KeynoteViewController</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">KeynoteViewController</span>()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> chatViewController: <span class="type">ChatViewController</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ChatViewController</span>()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - Add Child View Controllers</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupInterface</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        addChild(videoViewController)</span><br><span class="line">        addChild(keynoteViewController)</span><br><span class="line">        addChild(chatViewController)</span><br><span class="line"></span><br><span class="line">        view.addSubViews([</span><br><span class="line">            videoViewController.view,</span><br><span class="line">            keynoteViewController,</span><br><span class="line">            chatViewController</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里进行对子控制器的 View 的布局</span></span><br><span class="line"></span><br><span class="line">        videoViewController.didMove(toParent: <span class="keyword">self</span>)</span><br><span class="line">        keynoteViewController.didMove(toParent: <span class="keyword">self</span>)</span><br><span class="line">        chatViewController.didMove(toParent: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - Remove Child View Controller</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(asChild viewController: UIViewController)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Notify Child View Controller</span></span><br><span class="line">        viewController.willMove(toParent: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove Child View From Superview</span></span><br><span class="line">        viewController.view.removeFromSuperview()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notify Child View Controller</span></span><br><span class="line">        viewController.removeFromParentViewController()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的点是在做布局之前要使用 addChild(:) 方法，这样会触发子控制器的 willMove(toParent:) 方法，并且在布局完后要使用 didMove(toParent:) 方法。在移除 Child View Controller 的时候也需要重复相似的步骤，在移除 View 之前要使用 willMove(toParent:)， 在移除 View 之后使用 removeFromParentViewController() 方法。这样的做的好处是可以把子控制器的生命周期纳入父控制器的控制范围：在父控制器加入或者移除子控制器的时候能够触发子控制器的 viewWillAppear 和 viewWillDisappear 的方法。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>View Controller Containment 是一种非常实用的重构 UI 的设计模式，我在接触了这种模式后就开始欲罢不能（谁用谁知道）。这种模式不仅能增加代码的复用性和可拓展性，还可以将逻辑进行分离从而增加代码的可读性。所以把它加入你的 skill set 中会给你以后的工作和学习带来很大的益处。</p><div class="note info"><p>相关链接：</p><p><a href="https://cocoacasts.com/managing-view-controllers-with-container-view-controllers" target="_blank" rel="noopener">Managing View Controllers With Container View Controllers</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在工作过程中如何利用 View Controller Containment 来重构 UI&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Swift" scheme="http://cyberhex.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Design Pattern" scheme="http://cyberhex.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中的并发性问题</title>
    <link href="http://cyberhex.me/2018/11/27/concurrency-in-iOS/"/>
    <id>http://cyberhex.me/2018/11/27/concurrency-in-iOS/</id>
    <published>2018-11-27T05:39:41.000Z</published>
    <updated>2020-07-07T16:59:53.620Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在学习 iOS 的过程中关于并发性的问题。<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在开发过程中曾经遇到过挺多次并发的问题，比如在自己写 networking 代码的时候会遇到一些（对！我是自己手写 networking code， 老板禁止使用 Alamofire， 所以我就自己写了一个很小的库，以后有机会跟大家分享），但都是比较皮毛的东西，感觉自己并没有深入理解并发行的问题，现在下定决心好好研究一下并发性，毕竟面试会考挺多而且以后也会碰到很多。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在很多事情都是多线的，电脑是多核的，手机是双卡双待的，你看我，我可以一边写博客，一边玩LOL(呃，不知道为什么就抄袭了爱情公寓的台词，不过好像有点讽刺)。其实我是想说，由于现在手机是多核的，意味着同一时间手机可以同时处理多个问题，于是很多现代操作系统比如 iOS 和 OS10 就利用利用了这个特点而使用多线程。在这里我就想提出一个千古难题，进程和线程的区别是啥，说实话，到今天之前我对这两个概念还是比较模糊。进程的定义是正在执行程序的一个实体，线程定义是程序的执行路径。简而言之,在 iOS 系统中，进程可以理解为就是一个 App, 而线程是程序执行流的最小单元，一个进程至少有一个线程。其实我的理解也还没到完全的地步，大家可以参考<a href="https://juejin.im/post/5b1cf4fa6fb9a01e4b062771" target="_blank" rel="noopener">我所理解的 iOS 并发编程</a>和<a href="https://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="noopener">进程和线程的区别</a>。并发性有很多可以研究的问题，下面我想主要说一下 GCD 和 Operation Queue。</p><h2 id="Main-Queue-vs-Background-Queue"><a href="#Main-Queue-vs-Background-Queue" class="headerlink" title="Main Queue vs. Background Queue"></a>Main Queue vs. Background Queue</h2><p>在 iOS 中有两个重要的概念，Main Queue 和 Background Queue，这两个东西有什么用呢？ 试想一下，如果你每次打开抖音都会先白屏三秒钟才出现图片，那你还会这么没日没夜的刷它吗？ 如果出现这种情况，最有可能的情况只有两种：</p><ol><li>iPhone XS 在向你招手，扔掉手中的老手机，下一站，黑市交易所。</li><li>本来应该在 Background Queue 运行的 networking 奇瑞跑到了 Main Queue 的快车道上蹩住了你的校长牌阿斯顿 UI。</li></ol><p>一般情况下, 第二种情况发生的概率比较大。那么要怎么办呢？当然是利用你尊贵的身份改变交通规则，让开奇瑞的全部都去慢车道开，如果进入快车道，可以直接没收作案工具。这在现实生活中可能显得有点扯淡(?)。但是在 iOS 中不失为一种非常有效率的解决办法。 让运行较慢的 networking code 进入 Background Queue 运行，等到运行完成了再通知系统更新 UI。 这样就能大大提高用户体验，让用户刷抖音到天亮不是梦。</p><h2 id="Grand-Central-Dispatch-GCD"><a href="#Grand-Central-Dispatch-GCD" class="headerlink" title="Grand Central Dispatch(GCD)"></a>Grand Central Dispatch(GCD)</h2><p>先讲一点点历史， GCD 为什么要叫 Grand Central Dispatch 而不是 Large Central Dispatch 或者 Big Central Dispatch ? 这是由于在纽约有一个非常著名的地铁站叫 Grand Central Terminal，这个地方差不多是曼哈顿中一个地标型站点，后来程序员们在设计 GCD 的时候觉得在管理不同的线程的时候和 Grand Central Terminal 有异曲同工之妙，然后就堂而皇之的抄袭(程序猿的事能算抄吗）了这个名字。如果你是一个 iOS 开发员并且有幸去纽约玩的话一定要去膜拜一下这个有意义的站点。</p><p>GCD 作为苹果推荐的管理多线程的方式，肯定是有他的优势的，首先它的运行速度极快（每个 block 的运行速度是纳秒级别的）; 其次, GCD 的调用接口非常简单，只需要在最后的 closure 中写入要执行的代码就可以调用了，代码结构清晰，要做什么也显得一目了然，所以在网络请求和图片的异步加载中经常能看到它的身影。</p><p>GCD 中有两个核心的概念： 任务和队列</p><blockquote><p>任务</p></blockquote><p>GCD 中的任务就是加入到 closure 中的那一段代码，任务按照执行方式分为两种：</p><ol><li>同步执行的任务会阻塞当前线程，等待 closure 中的代码执行完成后当前线程才会继续。</li><li>异步执行的任务不会阻塞当前线程，当前线程会继续执行。</li></ol><blockquote><p>队列</p></blockquote><p>GCD 中队列指的是任务的等待队列，也就是在任务进入线程执行前排队的地方。队列遵循先进先出（FIFO）的原则，队列也分为两种：</p><ol><li>串行队列无法开启新的线程，所以线程中的任务会在当前线程一个一个执行，也就是说前一个任务执行完了下一个任务才会开始执行。这个就像在奶茶店门口买奶茶一样，只有上一个顾客买完了，下一个才可以买。</li><li>并行队列有开启新线程的能力，所以线程中的任务无需等待上一个任务完成就可以进入其他线程执行（但整个队列还是遵循先进先出的原则，只不过队列分发的特别快，看起来像一起执行）。这个就像在银行排队办理业务，因为有好多窗口，所以下一个人没必要等上一个人办理完业务才开始办理（除非窗口已全部被占用）。</li></ol><h3 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h3><p>在实际应用中，我们碰到的有三种常用队列：主队列，全局队列和自创队列。</p><p>首先我们先看自创队列：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="keyword">let</span> backgroundQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.cyberhex.concurrent.queue"</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure></p><p>上边就是创建队列的过程，DispatchQueue 的构造函数需要好多个参数，但是除了 label 其他的都是可选参数（如下），一般来说创建的队列都是并行队列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispathQueue 的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(label: <span class="type">String</span>, qos: <span class="type">DispatchQoS</span> = <span class="keyword">default</span>, attributes: <span class="type">DispatchQueue</span>.<span class="type">Attributes</span> = <span class="keyword">default</span>, autoreleaseFrequency: <span class="type">DispatchQueue</span>.<span class="type">AutoreleaseFrequency</span> = <span class="keyword">default</span>, target: <span class="type">DispatchQueue</span>? = <span class="keyword">default</span>)</span><br></pre></td></tr></table></figure><p>另外两个是可以直接调用无需创建，分别是主队列（Main Queue）和全局队列（Global Queue)。</p><p>其中主队列是串行队列，主要用于处理 UI 相关的任务，其他耗时的任务如网络请求或者下载图片需要另开线程进行处理，给 UI 大爷让路。</p><p>说到这个我想扯一个不是特别相关的，前一阵面试某条被问到了一个关于主队列的问题，具体是：为什么 UI 不能在主线程之外的线程运行，为什么系统会报错。说实话，我还真是没有了解过，面试完了以后查了资料才明白。</p><p>简单来说就是 UIKit 不是线程安全的，所以如果在其他线程更新 UI 会引起整个应用 UI 的混乱，具体为什么 UIKit 不是线程安全的等其他问题，大家可以看<a href="https://blog.csdn.net/qq_36557133/article/details/86531816" target="_blank" rel="noopener">这篇博客</a></p><p>回到正题，全剧队列是一个并行的队列，你可以把需要并行处理的任务交给它来处理。主队列和全局队列的获取如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispathQueue 的定义</span></span><br><span class="line"><span class="keyword">let</span> mainQueue = <span class="type">DispatchQueue</span>.main</span><br><span class="line"><span class="keyword">let</span> globalQueue = <span class="type">DispatchQueue</span>.global()</span><br></pre></td></tr></table></figure><p>GCD 就暂时先说到这里，我知道还有很多其他的东西比如信号量（Semaphore）和 DispatchWorkItem，这些以后有机会了再总结。</p><h2 id="Operation-和-Operation-Queue"><a href="#Operation-和-Operation-Queue" class="headerlink" title="Operation 和 Operation Queue"></a>Operation 和 Operation Queue</h2><p>Operation 是对于 GCD 的一个封装，相比于轻量级的 GCD，Operation 是完全面向对象的，它提供了多个接口可以实现暂停、继续、终止、优先顺序、依赖等复杂操作，比 GCD 更加灵活。在运行速度方面不如 GCD，是处于毫秒级别。</p><p>Operation 和 Operation Queue 对应与 GCD 的任务和队列，所以与之相对应的，它也有同步异步，串行并行之分，只不过表现形式不同。</p><h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>最后奉上我只在在某大厂笔试碰到的两道与GCD 和 Operation Queue 相关的题目。</p><ol><li>请写出下面代码执行顺序以及每次执行前等待了多长时间？并解释下原因？</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispathQueue 的定义</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                sleep(<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"1"</span>+<span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"2"</span> + <span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"3"</span> + <span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>如果把上面的DispatchQueue.main.async都改成DispatchQueue.global().async是怎么输出呢？并解释下原因？</p></li><li><p>如果下面这种情况请输出print输出顺序？并解释原因，如果maxConcurrentOperationCount = 1结果会是什么样子？</p></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispathQueue 的定义</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">OperationQueue</span>()</span><br><span class="line">        queue.maxConcurrentOperationCount = <span class="number">2</span></span><br><span class="line">        queue.addOperation &#123;</span><br><span class="line">            queue.addOperation &#123;</span><br><span class="line">                sleep(<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"1"</span>+<span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"2"</span>+<span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            queue.addOperation &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"3"</span>+<span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>答案我会在下一篇博客中揭晓。</p><div class="note info"><p>相关链接：</p><p><a href="https://teamtreehouse.com/library/concurrency-in-ios" target="_blank" rel="noopener">Tree House: Concurrency in iOS</a><br><a href="http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html" target="_blank" rel="noopener">Linus Torvalds 的邮件</a><br><a href="https://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="noopener">进程和线程的区别</a><br><a href="https://juejin.im/post/5b1cf4fa6fb9a01e4b062771" target="_blank" rel="noopener">我所理解的 iOS 并发编程</a><br><a href="http://khanlou.com/2016/04/the-GCD-handbook/" target="_blank" rel="noopener">The GCD Handbook</a><br><a href="https://www.objc.io/issues/2-concurrency/" target="_blank" rel="noopener">OBJC Concurrent Programming</a><br><a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="noopener">iOS 多线程：『GCD』详尽总结</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在学习 iOS 的过程中关于并发性的问题。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://cyberhex.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://cyberhex.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Concurrency" scheme="http://cyberhex.me/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 中 Nullability 的使用</title>
    <link href="http://cyberhex.me/2018/11/25/nullability-annotations-in-objective-c/"/>
    <id>http://cyberhex.me/2018/11/25/nullability-annotations-in-objective-c/</id>
    <published>2018-11-25T14:23:19.000Z</published>
    <updated>2020-06-14T11:00:22.148Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在学习 Objective-C 的过程中关于 Nullability 的问题。<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们都知道 Swift 和 Objective-C 可以同时存在于同一个 project 中，但想让他们俩兄弟同时幸福快乐和谐的生活在同一个项目中并不是一件容易的事。 Swift 小老弟最大的优势就是 Type Safety, 而 Objective-C 老大哥最大的“问题”就是可以有满屏的 nil。 在 Swift 中如果你想在不初始化一个变量的情况使用这个变量，你必须要提前告知 Xcode 这个变量是 optional 的， 但是 Objective-C 就没有这样的要求。 那么怎么解决这个问题呢，苹果最后引入了 Nullability 来给 Objective-C 加入一些安全保障。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>在 Objective-C 中有以下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *username;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *password;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)loginWithUsername:(<span class="built_in">NSString</span> *)username</span><br><span class="line">                 password:(<span class="built_in">NSString</span> *)password;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>但是如果这段代码是存在与两种语言混合的项目中，这段代码 import 进如 Swift 之后就成了一下这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">var</span> password: <span class="type">String</span>!</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(withUsername username: String!,</span></span></span><br><span class="line"><span class="function"><span class="params">                            password: String!)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了满屏的惊叹号，这对于有强迫症的同学简直是一种煎熬，为什么会这样呢？<br>因为 Swift 是 Type Safe 的语言，除非你提前申明这个变量是 optional，否则他不会让你随便给变量赋值 nil。</p><p>但是，如果在 Objective-C 中引入了 Nullability， 这个问题就会大大改善，比如下边的例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonnull</span>, <span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *username;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *password;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)loginWithUsername:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)username</span><br><span class="line">                 password:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)password;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 Swift 中，接口就会变成以下的情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> password: <span class="type">String</span>？</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(withUsername username: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                            password: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，虽然这样解决的 Swift 和 Objective-C 之间搭桥的问题，Objective-C 本身并没有发生改变，他还是该吃吃，该喝喝，runtime 的行为模式和以前没啥区别，毕竟嘛，那什么改不了那啥。但是经过这样的改变，compiler 会站出来在我们用错 API 的时候提出警告。</p><h2 id="四种-Nullability-标记"><a href="#四种-Nullability-标记" class="headerlink" title="四种 Nullability 标记"></a>四种 Nullability 标记</h2><table><thead><tr><th style="text-align:center">Pointers</th><th style="text-align:center">Properties</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">_Null_unspecified</td><td style="text-align:center">null_unspecified</td><td style="text-align:center">默认值，在搭桥到 Swift 后会成为 unwrapped optional</td></tr><tr><td style="text-align:center">_Nonnull</td><td style="text-align:center">nonnull</td><td style="text-align:center">在搭桥到 Swift 后变成正常变量声明</td></tr><tr><td style="text-align:center">_Nullable</td><td style="text-align:center">nullable</td><td style="text-align:center">在搭桥到 Swift 后变成 optional</td></tr><tr><td style="text-align:center">N/A</td><td style="text-align:center">null_resettable</td><td style="text-align:center">这种变量在读的时候不会是 nil， 但是可以重置为nil</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这算是我第一篇正儿八经的博客了，也算是学习笔记性质的记录博客，所以内容不一定是完全正确的，所以还希望各位大佬不吝赐教，大家一起学习。</p><div class="note info"><p>相关链接：</p><p><a href="https://teamtreehouse.com/library/nullability-annotations-in-objectivec" target="_blank" rel="noopener">Tree House: Nullability Annotations in Objective-C</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在学习 Objective-C 的过程中关于 Nullability 的问题。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://cyberhex.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://cyberhex.me/tags/Objective-C/"/>
    
      <category term="Nullability" scheme="http://cyberhex.me/tags/Nullability/"/>
    
  </entry>
  
  <entry>
    <title>写在前面的话</title>
    <link href="http://cyberhex.me/2018/11/22/initial-post/"/>
    <id>http://cyberhex.me/2018/11/22/initial-post/</id>
    <published>2018-11-22T05:27:54.000Z</published>
    <updated>2019-03-17T12:17:34.609Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">梦里不知身是客，直把他乡作故乡。</blockquote><br><a id="more"></a></p><p>这可能是来美国这四年来我第一次静下心来想好好写点东西。现在的我，蜗居在一间租来的短租房里，在美国这个大农村里卖掉了可能是生活中最重要的必备品 - 车，考虑着自己怎么会沦落到这个地步。生活与生存、梦想与现实，对于我来说不是选择题，而更像是灰掉了一个选项的无奈。可能是时候回国寻找下一个人生目标了，就算有再多的不甘心。</p><h2 id="时空锥"><a href="#时空锥" class="headerlink" title="时空锥"></a>时空锥</h2><p>曾几何时，我的脑子里想着的都是相对论，康德哲学，甚至怎么样改变世界。不知从何时开始，我关心的事情完全变成了怎么样活下去。不管怎么说，在于生活的这场战争中，我是败得一派涂地。</p><p>我对相对论中的时空锥和因果律深信不疑，不知到在之前的哪个时空节点发生的事件或者是别人的时空锥的介入，让我的人生有了如此大的变化。但是这也许是命，也许是运，谁知道呢？</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>毕竟有很长时间已经没有写东西了，本来有好多想说的话，但手放在键盘的那一刻就全忘了，能写这么些东西可能已经是绞尽脑汁了。现在说说自己接下来几个月的计划吧。</p><ol><li>作为一个iOS Developer，我现在只会swift语言，而对于ojective-c只是知道一些皮毛，所以接下来的一段时间我要好好地学一下objective-c。</li><li>争取每学一些新的知识都把它们整理成学习笔记，这样不仅对我自己来说是一个很好的复习，对于未来可能大概也许来我博客的读者也会有很大帮助。</li><li>好好锻炼身体，可能有两三个月没有好好健身了，是时候在回国之前塑造一下新的形象。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然感觉自己很失败，但是危机并不是一个贬义词，危险与机会并存，就看自己怎么把握，说不定就走狗屎运咸鱼翻身了呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;梦里不知身是客，直把他乡作故乡。&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://cyberhex.me/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="http://cyberhex.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
