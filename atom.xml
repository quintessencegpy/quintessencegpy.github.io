<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CyberHex</title>
  
  <subtitle>Simple(r) Always Wins.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cyberhex.me/"/>
  <updated>2020-07-19T17:15:56.706Z</updated>
  <id>http://cyberhex.me/</id>
  
  <author>
    <name>Penstein</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARTS 打卡 06</title>
    <link href="http://cyberhex.me/2020/07/20/arts-06/"/>
    <id>http://cyberhex.me/2020/07/20/arts-06/</id>
    <published>2020-07-19T16:35:51.000Z</published>
    <updated>2020-07-19T17:15:56.706Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>K 个一组翻转链表（LeetCode 25，困难）</p><p>这个题真的是就算知道怎么做也是要写错好几回，我这次的 AC 率是 6，感觉链表的题还是要多练才行。还有 Dummy Node 的技巧也很重要。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>这周看了这篇教程：<a href="https://www.raywenderlich.com/7408-testing-your-rxswift-code#toc-anchor-005" target="_blank" rel="noopener">Testing Your RxSwift Code</a></p><h3 id="RxTest-VS-RxBlocking"><a href="#RxTest-VS-RxBlocking" class="headerlink" title="RxTest VS. RxBlocking"></a>RxTest VS. RxBlocking</h3><p>两个在 Rx 的测试中都非常有用，RxBlocking 更加直观，RxTest 更加全面。</p><p>RxTest 可以覆盖大部分测试，而且 TestScheduler 模拟的虚拟时间可以大大缩短测试时间，但是写起来比较长也比较麻烦</p><p>相比 RxBlocking 写起来非常简单也直观，但使用场景比较局限，其中对我们来说比较致命的一点是 RxBlocking 对于无法停止的序列的测试能力很有限，并不能提供我们需要的能力。而我们直播中大部分序列都是无限序列，所以暂时不考虑 RxBlocking。</p><p>还有一点就是，RxBlocking 无法测试时间相关的用例，比如我在 1s的时候收到一个信号，想测试输出是否在 1s的时候输出某个特定值，RxBlocking 只能测试出来收到了这个值，但是不能确定时间戳。RxBlocking 比较适合测试初始值，或者只有一个状态的序列。</p><p>RxBlocking 也会 block 住当前线程，所以之前发生过的，测试走到 RxBlocking的语句之后，就会卡死并且无法继续进行测试也是这个引起的（我们使用了 BehaviorRelay 是无限序列）。</p><p>所以之后的测试还是需要继续使用 RxTest，以上。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>这次没发现特别骚的套路，所以先鸽了</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><h3 id="什么时候需要写单测"><a href="#什么时候需要写单测" class="headerlink" title="什么时候需要写单测"></a>什么时候需要写单测</h3><p>并不是所有的代码都需要你写单测来保证的，总结起来就是“三个不一个要”：</p><ol><li>不给自动生成的代码写 Unit Test（比如生成的 getter setter），我们要相信 Xcode（或者其他编辑器），出了问题是天灾，需要我们单独分情况处理，然后给我们自己处理的代码写单测。</li><li>不给编译器能发现的问题写 Unit Test，这个不是你需要关心的。</li><li>不给第三方库写 Unit Test，所谓疑人不用，用人不疑，你既然辛辛苦苦选择了一个靠谱的第三方库，就要相信他。如果出问题的话处理方式同第一点。</li><li>要给自己写的无法用编译器发现问题的代码写 Unit Test，包括自己写的 Class，Method 等。</li></ol><p>总结一下，上边的原则看起来挺多，其实就是一句话：上帝的归上帝，凯撒的归凯撒，自己的锅自己背，别人的锅我不管。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>尤尼泰斯特 2020 - 回忆篇</title>
    <link href="http://cyberhex.me/2020/07/07/unit-test-short-story-01/"/>
    <id>http://cyberhex.me/2020/07/07/unit-test-short-story-01/</id>
    <published>2020-07-07T14:29:11.000Z</published>
    <updated>2020-07-19T16:11:24.560Z</updated>
    
    <content type="html"><![CDATA[<p>泰斯特探长与菲托尔的爱恨情仇<br><a id="more"></a></p><h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>“铃铃铃…”，一阵急促的电话声吵醒了泰斯特探长，他下意识地看了一眼手机，骂骂咧咧的说一句：“我都关了静音了，到底哪在响？！”这时候电话又响了一声，警探这才反应过来，这是警局内线的电话，只有在紧急情况下才会响。上次听到这个铃声是几年前的事情了，他瞬间紧张了起来，但又一时间没有想起配枪放在哪里，就拿了衣橱里的棒球棍，慌慌张张向地下室走去。走到一半的时候突然想起来配枪放在了书房的保险箱里边，于是他还是决定先去拿了配枪再接电话。电话还是响个不停，他破口大骂：“催个鬼啊，马上到了！”一顿折腾，他终于来到了电话旁边，拿起电话，对面是一个略显稚嫩和颤抖的声音：“泰斯特探长，抱歉吵醒您，警局…”“别那么多废话，什么紧急情况？”泰斯特探长打断了这个年轻人的话，“是菲托尔，他又出现了”泰斯特探长心脏一抽，碰倒了桌上的笔筒，里边的笔掉了一地，电话那边传来急促的声音“探长，您没事吧？！”泰斯特探长还没从刚才的惊讶中回过神来，电话那边又传了声音“您还在吗？没事，您这次一定能将他绳之以法，我们都尽最大努力…”“这还用得着你说，我马上过去!”他砰的一声挂掉了电话，他倒吸了一口气，默念了一句“怎么又是你？”陷入了回忆。</p><h2 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h2><p>十年前，那会泰斯特还是一个刚入职刚满两年的年轻警探，是蔻丁市有史以来最年轻的优秀警探。</p><p>时间有限先写这么多，一直想写一个短片小说，觉得单测给了我好多灵感，写一个关于单测的小说也算圆了我的小说梦。哈哈哈哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泰斯特探长与菲托尔的爱恨情仇&lt;br&gt;
    
    </summary>
    
      <category term="戏说就是胡说" scheme="http://cyberhex.me/categories/%E6%88%8F%E8%AF%B4%E5%B0%B1%E6%98%AF%E8%83%A1%E8%AF%B4/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 尾声</title>
    <link href="http://cyberhex.me/2020/07/07/tdd-part-five/"/>
    <id>http://cyberhex.me/2020/07/07/tdd-part-five/</id>
    <published>2020-07-06T16:57:32.000Z</published>
    <updated>2020-07-19T16:11:09.106Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷五），本系列链表头部请戳 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷五），本系列链表头部请戳 &lt;a href=&quot;https://cyberhex.me/2020/06/14/tdd-part-one/&quot;&gt;A song of TDD and BUG - 前奏曲&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 变奏曲</title>
    <link href="http://cyberhex.me/2020/07/07/tdd-part-four/"/>
    <id>http://cyberhex.me/2020/07/07/tdd-part-four/</id>
    <published>2020-07-06T16:47:32.000Z</published>
    <updated>2020-07-19T16:07:15.020Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷四），本系列链表头部请戳 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a><br><a id="more"></a></p><h2 id="历史代码-TDD-改造需要注意的问题"><a href="#历史代码-TDD-改造需要注意的问题" class="headerlink" title="历史代码 TDD 改造需要注意的问题"></a>历史代码 TDD 改造需要注意的问题</h2><h3 id="Start-Small"><a href="#Start-Small" class="headerlink" title="Start Small"></a>Start Small</h3><h3 id="Choose-Your-BattleField"><a href="#Choose-Your-BattleField" class="headerlink" title="Choose Your BattleField"></a>Choose Your BattleField</h3><p>记得写单测并不是你的目的，减少 Bug 才是，所以我们需要把有限的精力放在收益最大的单侧上。我推荐两种选择写单测优先级的方案：</p><ol><li>利用时间局部性：就像 LRU 的思想一下，在最近一段时间修改过的逻辑很有可能在未来一段时间内也需要修改，所以选择用单侧保证这部分逻辑有助于之后的迭代和重构。</li><li>“从”新开始：主意是从新，不是重新，也就是暂时考虑放弃之前的逻辑，对新业务使用 TDD 的开发模式来开发。这种比较适合没有时间对老代码进行重构和改造的情况，先对新的业务进行单测，等到业务稳定以后再考虑之前的历史包袱。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷四），本系列链表头部请戳 &lt;a href=&quot;https://cyberhex.me/2020/06/14/tdd-part-one/&quot;&gt;A song of TDD and BUG - 前奏曲&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 副歌</title>
    <link href="http://cyberhex.me/2020/07/07/tdd-part-three/"/>
    <id>http://cyberhex.me/2020/07/07/tdd-part-three/</id>
    <published>2020-07-06T16:37:20.000Z</published>
    <updated>2020-07-19T16:07:06.109Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷三），本系列链表头部请戳 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a><br><a id="more"></a></p><h2 id="副歌不副，FTDD-不-F"><a href="#副歌不副，FTDD-不-F" class="headerlink" title="副歌不副，FTDD 不 F"></a>副歌不副，FTDD 不 F</h2><p>可能你在想，不是 A song of TDD and BUG 吗？怎么都到了副歌部分了，还没怎么说 TDD。这个可能就要怪我们民国的大师们把 Chorus 翻译成副歌了，明明是最高潮的部分，翻译成副歌总给人一种莫名其妙的感觉，不过也可能是我乐理不精对大师的翻译没有深刻理解导致的。那吐槽吐完，开始讲正事，之前有给过大家一个强烈但不失友善的警告大家应该还记得吧，不记得的可以去复习一下 <a href="https://cyberhex.me/2020/07/07/tdd-part-two/">A song of TDD and BUG - 主歌</a>。那会我说过适合自己的才是最好的，俗话说的好，规则就是用来打破的，只要我们了解了 TDD 的真谛，就可以把它改造成最适合自己的开发模式，我把这些 TDD 的变种们称为 FTDD。那何谓 FTDD，这个多出来的 F 代表什么？其实就是 Fu..，不好意思，是 Fake，也就是“伪 TDD”。那为什么说 FTDD 不 F 呢？因为这个“伪”并不是真正意义上的伪，而是结合了自己对 TDD 的理解和实践的产物，也可以理解为 F(it)TDD，也就是合适的 TDD。</p><h2 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h2><h2 id="劝分不劝和"><a href="#劝分不劝和" class="headerlink" title="劝分不劝和"></a>劝分不劝和</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷三），本系列链表头部请戳 &lt;a href=&quot;https://cyberhex.me/2020/06/14/tdd-part-one/&quot;&gt;A song of TDD and BUG - 前奏曲&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 主歌</title>
    <link href="http://cyberhex.me/2020/07/07/tdd-part-two/"/>
    <id>http://cyberhex.me/2020/07/07/tdd-part-two/</id>
    <published>2020-07-06T16:27:20.000Z</published>
    <updated>2020-07-19T16:06:42.070Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷二），本系列链表头部请戳 <a href="https://cyberhex.me/2020/06/14/tdd-part-one/">A song of TDD and BUG - 前奏曲</a><br><a id="more"></a></p><h2 id="FBI-Warning"><a href="#FBI-Warning" class="headerlink" title="FBI Warning"></a>FBI Warning</h2><p>我知道你在想啥，但是你想多了，我只是想给你一个强烈但不失友善的警告（Friendly But Intense Warning）而已。在了解 TDD 之前你需要知道，TDD 只是一种开发模式，不是圣经也不是行为准则，我们需要辩证的去看待 TDD，可以参照 TDD 并且结合自己的实际情况选择最适合自己的开发模式，毕竟适合自己的才是最好的。这你可能会问了，刚你还说 TDD 又是最耀眼的新星，又是救世主的，现在咋又说人家坏话。我想说的是，你毕竟还是 Too Young，要我不进行一波商业吹嘘，你可能也不愿意往下看啊，流量称王的时代，我不得忽悠你多看几眼啊。</p><h2 id="什么时候需要写单测"><a href="#什么时候需要写单测" class="headerlink" title="什么时候需要写单测"></a>什么时候需要写单测</h2><p>并不是所有的代码都需要你写单测来保证的，总结起来就是“三个不一个要”：</p><ol><li>不给自动生成的代码写 Unit Test（比如生成的 getter setter），我们要相信 Xcode（或者其他编辑器），出了问题是天灾，需要我们单独分情况处理，然后给我们自己处理的代码写单测。</li><li>不给编译器能发现的问题写 Unit Test，这个不是你需要关心的。</li><li>不给第三方库写 Unit Test，所谓疑人不用，用人不疑，你既然辛辛苦苦选择了一个靠谱的第三方库，就要相信他。如果出问题的话处理方式同第一点。</li><li>要给自己写的无法用编译器发现问题的代码写 Unit Test，包括自己写的 Class，Method 等。</li></ol><p>总结一下，上边的原则看起来挺多，其实就是一句话：上帝的归上帝，凯撒的归凯撒，自己的锅自己背，别人的锅我不管。</p><h2 id="如何做一只合格的单测"><a href="#如何做一只合格的单测" class="headerlink" title="如何做一只合格的单测"></a>如何做一只合格的单测</h2><p>如果单测界也需要面试，那单测的招聘广告一定是下面这样的：</p><ol><li>你必须是可失败的，禁止使用如 Assert True 为 True 这样的作弊手段来保证自己的正确性，一经发现，必将诉诸法律手段。</li><li>你必须是可重复的，不能在多次的测试中给出不同的结果，否则你就会失去工作。</li><li>你必须是有效率的，不能干活磨磨唧唧的，可别忘了，我们这每次测试都需要跑很多单测，如果你处理工作超过 100 ms 就是不合格的。</li></ol><p>突然有点心疼单测的工作，但是我们能怎么办呢，人生不如意十有八九，更何况单测呢。</p><h2 id="单测的命名规则"><a href="#单测的命名规则" class="headerlink" title="单测的命名规则"></a>单测的命名规则</h2><p>这里有的小朋友就可能要问了，我写的单测我做主，我就要给他命名成 test1，test10086，testMyLove，你管我。这些小朋友一看就没有经历过社会的毒打，作为一个腿都被打断的过来人，我给你分享一点人生的经验。比如你刚进行了一次重构，突然发现有个名叫 testYouDidntGiveMeAMeaningfulNameAndNowYouSuckIt 的单测出了问题，你根本不知道他具体是代表了哪个地方出问题，你得需要在众单测中先找到这个单测，然后大概看一下测了什么并且心里一直在想给之前写单测的自己扇一大耳光，这会令你浪费很多宝贵的时间。在理解了命名的重要性后，下边我就分享一个比较通用的命名规则：</p><ol><li>对于每一个 class 有一个对应的 Unit Test 文件，命名规则为原文件名 + Tests，比如想给 ViewModel 写 Unit Test 就叫 ViewModelTests</li><li>测试函数名规则：test + 要被测试的函数名/变量名 +  _ + 状态 + _ + 所期望的结果，比如一个叫 state 的输出在初始化之后是否为 normal，函数名就应该是 testStudentState_whenInit_isNormal</li><li>什么是 sut：sut stands for  “System Under Test”，平时我们用 sut 来表示需要被测试的对象，比如在 ViewModelTests 中 sut 就是 ViewModel 的实体，即 sut = KeynoteViewModel()</li></ol><h2 id="Given，When，Then"><a href="#Given，When，Then" class="headerlink" title="Given，When，Then"></a>Given，When，Then</h2><p>这三个是单元测试的三个基本步骤（如此 skr 的命名方式，相信前辈也是一名单压狂魔吧）：</p><ol><li>Given 是指初始状态，也就是 sut 的初始状态。</li><li>When 是指一个发生在 sut 上的事件或者状态变化。</li><li>Then 是指在状态变化后来测试 sut 的状态与期望的状态是否相同。</li></ol><h2 id="Gearing-Up"><a href="#Gearing-Up" class="headerlink" title="Gearing Up"></a>Gearing Up</h2><p>相信你已经摩拳擦掌，迫不及待的想开始了。但是少侠稍安勿躁，行走江湖没有一件趁手的装备怎么行。这里我就以 iOS 为例来探讨一下单测框架的选择。选择框架需要考虑几个方面的问题：</p><ol><li>学习成本：我把这个列在第一位，是因为时间就是金钱，谁也不愿意花费大量时间学习一个晦涩难懂的框架。</li><li>易用性：这个就不用我多说了吧，一个好用的框架能让你事半功倍，反之，事半功半半半。</li><li>可读性：这个也很重要，因为很多情况下单测只是用来测试代码的，也可以作为了解业务逻辑的一种方法。</li><li>附加价值：这个就很笼统了，比如有的框架内置 BDD，有的和其他库 - 比如 Mock 数据的库（为什么要把 Mock 单独拿出来说，之后你就会明白）- 更加贴合，这些都可以成为框架的附加价值。</li></ol><p>接下来我就以 iOS 中的两个常用的框架做一下比较，下边有请本段的双主角 XCTest 和 Quick &amp; Nimble。先交代一下故事的背景，XCTest 是苹果自带的单测框架，而 Quick &amp; Nimble 是基于 XCTest 发展出来的一个框架，具有非常独特的语法和使用方式，但是底层的 Assertion 等和 XCTest 非常相似。</p><p>我们先直观的看一下两个框架的测试代码都长什么样：</p><p>首先是苹果自带的 XCTest：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeekDayViewModelTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sut: <span class="type">WeekDayViewModel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Load Stub</span></span><br><span class="line">        <span class="keyword">let</span> data = loadStub(name: <span class="string">"darksky"</span>, <span class="class"><span class="keyword">extension</span>: "<span class="title">json</span>")</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        // <span class="title">Initialize</span> <span class="title">JSON</span> <span class="title">Decoder</span></span></span><br><span class="line"><span class="class">        <span class="title">let</span> <span class="title">decoder</span> = <span class="title">JSONDecoder</span>()</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        // <span class="title">Configure</span> <span class="title">JSON</span> <span class="title">Decoder</span></span></span><br><span class="line"><span class="class">        <span class="title">decoder</span>.<span class="title">dateDecodingStrategy</span> = .<span class="title">secondsSince1970</span></span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        // <span class="title">Initialize</span> <span class="title">Dark</span> <span class="title">Sky</span> <span class="title">Response</span></span></span><br><span class="line"><span class="class">        <span class="title">let</span> <span class="title">darkSkyResponse</span> = <span class="title">try</span>! <span class="title">decoder</span>.<span class="title">decode</span>(<span class="title">DarkSkyResponse</span>.<span class="title">self</span>, <span class="title">from</span>: <span class="title">data</span>)</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        // <span class="title">Initialize</span> <span class="title">View</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class">        <span class="title">sut</span> = <span class="title">WeekDayViewModel</span>(<span class="title">weatherData</span>: <span class="title">darkSkyResponse</span>.<span class="title">forecast</span>[5])</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">override</span> <span class="title">func</span> <span class="title">tearDown</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.tearDown()</span><br><span class="line">        sut = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testDay_whenGetData_isExpected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(sut.day, <span class="string">"Sunday"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testDate_whenGetData_isExpected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(sut.date, <span class="string">"September 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testTemperature_whenGetData_isExpected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(sut.temperature, <span class="string">"12.2 °C - 20.1 °C"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testWindSpeed_whenGetData_isExpected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">XCTAssertEqual</span>(sut.windSpeed, <span class="string">"5 MPH"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是倔强的 Quick &amp; Nimble：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeekDayViewModelTests</span>: <span class="title">QuickSpec</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">spec</span><span class="params">()</span></span> &#123;</span><br><span class="line">        describe(<span class="string">"a WeekDayViewModel"</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sut: <span class="type">WeekDayViewModel</span>!</span><br><span class="line">            </span><br><span class="line">            beforeEach &#123;</span><br><span class="line">                <span class="keyword">let</span> data = <span class="keyword">self</span>.loadStub(name: <span class="string">"darksky"</span>, <span class="class"><span class="keyword">extension</span>: "<span class="title">json</span>")</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                // <span class="title">Initialize</span> <span class="title">JSON</span> <span class="title">Decoder</span></span></span><br><span class="line"><span class="class">                <span class="title">let</span> <span class="title">decoder</span> = <span class="title">JSONDecoder</span>()</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                // <span class="title">Configure</span> <span class="title">JSON</span> <span class="title">Decoder</span></span></span><br><span class="line"><span class="class">                <span class="title">decoder</span>.<span class="title">dateDecodingStrategy</span> = .<span class="title">secondsSince1970</span></span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                // <span class="title">Initialize</span> <span class="title">Dark</span> <span class="title">Sky</span> <span class="title">Response</span></span></span><br><span class="line"><span class="class">                <span class="title">let</span> <span class="title">darkSkyResponse</span> = <span class="title">try</span>! <span class="title">decoder</span>.<span class="title">decode</span>(<span class="title">DarkSkyResponse</span>.<span class="title">self</span>, <span class="title">from</span>: <span class="title">data</span>)</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">                <span class="title">sut</span> = <span class="title">WeekDayViewModel</span>(<span class="title">weatherData</span>: <span class="title">darkSkyResponse</span>.<span class="title">forecast</span>[5])</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">           </span></span><br><span class="line"><span class="class">            <span class="title">afterEach</span> </span>&#123;</span><br><span class="line">                sut = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"its day"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"is Sunday"</span>) &#123;</span><br><span class="line">                        expect(sut.day).to(<span class="built_in">equal</span>(<span class="string">"Sunday"</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"its date"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"it is September 2"</span>) &#123;</span><br><span class="line">                        expect(sut.date).to(<span class="built_in">equal</span>(<span class="string">"September 2"</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"its temperature"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"is 12.2 °C - 20.1 °C"</span>) &#123;</span><br><span class="line">                        expect(sut.temperature).to(<span class="built_in">equal</span>(<span class="string">"12.2 °C - 20.1 °C"</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            describe(<span class="string">"its windSpeed"</span>) &#123;</span><br><span class="line">                context(<span class="string">"when got weather data"</span>) &#123;</span><br><span class="line">                    it(<span class="string">"is 5 MPH"</span>) &#123;</span><br><span class="line">                        expect(sut.windSpeed).to(<span class="built_in">equal</span>(<span class="string">"5 MPH"</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上边分别是两个框架对 WeekDayViewModel 的单元测试，你可以明显感觉到两个库的风格。说不定你可能就只是在库群中对其中某个多看了一眼，然后再也忘不掉它的优雅。但是选一个框架跟结婚一样，不止需要看对眼，还需要考虑很多现实的问题，要不然破裂的时候，就不只是“不和它一起维护代码”了那么简单了，还需要考虑重构，移除依赖，选择一个新的库一起维护代码，都说戏如人生，写代码也何尝不是如此呢。接下来，我就给你用上边的几个原则理性的分析一波，但是不管我分析的结果是什么，决定权都在你手上。可别忘了：</p><blockquote><p>人是感性的生物，如果是真爱，去他喵的理性分析。</p></blockquote><ol><li>Round 1：学习成本。XCTest 作为苹果的亲儿子，不论文档还是教程都比 Quick &amp; Nimble 这个“孤儿”要多很多，再加上 Quick &amp; Nimble 的使用方式比较特别，需要一点适应的时间，所以第一局 XCTest 胜。</li><li>Round 2：易用性。其实如果花时间学习了其中任意一种框架的话，用起来的难易程度都差不多（当然这么说的比较主观，但是感觉应该不是有特别大的出入）。这一局算平局。</li><li>Round 3：可读性。XCTest 中每一个测试都是独立的，如果对于同一个属性有不同的测试，我们需要人工的把它们归在一起，如果稍有不慎，就很容易混乱难找（单测一般都挺长的，尤其是加了Mocking 以后）。但是 Quick &amp; Nimble 我们可以天然的把相同属性的测试都归在同一个 describe 下边。所以这一局算 Quick &amp; Nimble 胜。</li><li>Round 4：附加价值。之前经过一番对比，两边各有胜负，最后又回到了起点，所以这一局算是胜负手。我主要想从对 BDD 的支持的方面来说，用 XCTest 你当然也可以结合 BDD 的思路来写单测，但是这个需要你人工的去维护。这时候 Quick &amp; Nimble 可就突然兴奋起来了，它对于 BDD 可是有天然的亲和力的。BDD 中的核心思想 GWT（也就是之前说过的 Given/When/Then）等价于 Quick &amp; Nimble 中的 descirbe，context，和 it（这几个在后边都会说到）。所以最终的 Winner 属于虽然是“孤儿”但仍能逆风 Carry 的 Quick &amp; Nimble。</li></ol><p>最后我还是想重申一下，上边的结论带有很大的主观性，对于不同的人来说结果肯定是有所出入的。但我觉得选择的过程还是可以被借鉴的，甚至如果你有选择困难症的话，甚至可以参考 SWOT 分析法来选择。</p><h2 id="真正的开始"><a href="#真正的开始" class="headerlink" title="真正的开始"></a>真正的开始</h2><p><a href="https://github.com/quintessencegpy/Rainstorm" target="_blank" rel="noopener">Rainstorm</a> 是一个非常简单直观但是又能 cover 我想说的大部分内容的项目，他是一个单页面的 App，页面上半部分是实时的天气，下边是接下来几天的天气预报，在这里我就不截图了，感兴趣的可以按照 ReadMe 里的一步一步跑一下项目， 如果你是懒人党，就凭空脑补一下 iOS 自带天气 App就行。什么，你不是 iOS 用户？那你就随手百度一下图片。什么，不会百度？不好意思，杠精出门右转，ETC 在左手边。</p><p>关于如何创建项目和加入 Unit Test 我就不在这里赘述了，但是我需要提的一点是关于 Podfile。如果你是第一次在 Unit Test 加入 Pod 的话需要注意一下，因为在主项目中你并不会用到 Unit Test 的 Pod，但是在 Unit Test 中你大概率会用到主项目的 Pod，所以需要做一下下边的骚操作：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">'Rainstorm'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Comment the next line if you don't want to use dynamic frameworks</span></span><br><span class="line">  use_frameworks!</span><br><span class="line">  pod <span class="string">'SnapKit'</span></span><br><span class="line">  <span class="comment"># Pods for Rainstorm</span></span><br><span class="line">  target <span class="string">'RainstormTests'</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line">    pod <span class="string">'Quick'</span></span><br><span class="line">    pod <span class="string">'Nimble'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>好了，废话说的够多了，我们开始写第一个单测。</p><h2 id="第一个单测"><a href="#第一个单测" class="headerlink" title="第一个单测"></a>第一个单测</h2><p>简单的讲一下 Quick &amp; Nimble 的使用<br>贴出具体学习链接<br><a href="https://www.raywenderlich.com/135-behavior-driven-testing-tutorial-for-ios-with-quick-nimble#toc-anchor-010" target="_blank" rel="noopener">Behavior-Driven Testing Tutorial for iOS with Quick &amp; Nimble</a></p><h2 id="做单测永远滴神"><a href="#做单测永远滴神" class="headerlink" title="做单测永远滴神"></a>做单测永远滴神</h2><p>在单测中，你要有猛虎归山，蛟龙如海，王者混入青铜局的气势，要有那种掌控雷电，呼风唤雨的感觉才对。为什么要这么说呢，你需要对单测的输入，流程，输出有绝对的控制权。但是这个神不是你想做，想做就能做的，你需要两个非常忠实的奴仆 - 抽象层和 Mocking。</p><h3 id="光明使者抽象层"><a href="#光明使者抽象层" class="headerlink" title="光明使者抽象层"></a>光明使者抽象层</h3><blockquote><p>单测的一个“副作用”就是揭开你代码的最后一块遮羞布 - 很多问题比如逻辑太分散，耦合度太高等问题都会会暴露无疑。因为这一次面对这些问题的人不再是别人，而是你自己。</p></blockquote><p>人们都说单测是检验代码质量的重要标准，有这种说法的很大原因都是抽象层的功劳，所以它也不愧光明使者，因为有了它你也就有了一把如意神剑（能看懂这个的都是老中二了）。那你肯定想说，吹了半天，总得说出点名堂吧。还记得那句经典名言吗？</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote><p>这个中间层放在这里指的就是抽象层。</p><p>拿 Rainstorm 来举例，因为我们是需要从网络拿到天气数据，然后才能展示。这时候你可能就会犯嘀咕，这种单测该怎么写？之前不是说了单测需要保证可重复性，我每次从网络拿到的数据又不可靠，怎么保证可重复性？如果你有这些疑问，说明你已经上道了，不愧是你小机灵鬼。其实这个问题答案就是这部分的核心思想，你要做单测永远滴神。既然从网络那边拿到的数据不可靠，我们就自己模拟，这也是马上要说的 Mocking。但是模拟一次网络请求也太麻烦了，有没有什么更好的方法？这就可以回归主题 - 抽象层了。如果我们在 ViewModel（我只是以 MVVM 举例，可以是任何 class） 和 Networking 之间加一层抽象这个问题就迎刃而解。在 Rainstorm 中这个抽象层叫 NetworkService，它只是提供接口，所以不管数据是从网络来，还是单测中的 Stubs，对于 ViewModel 来说都是透明的。这样一来，不仅解决了单测的问题，你的代码复用性也更高了。比如之后你想换网络层的库，只要接口不变，ViewModel 的代码就不用改。抽象层把路铺好了，接下来怎么操作就要看 Mocking 的了。</p><h3 id="堕落天使-Mocking"><a href="#堕落天使-Mocking" class="headerlink" title="堕落天使 Mocking"></a>堕落天使 Mocking</h3><h2 id="Networking-代码的单测"><a href="#Networking-代码的单测" class="headerlink" title="Networking 代码的单测"></a>Networking 代码的单测</h2><p>异步测试方法</p><h2 id="隐藏的-Boss"><a href="#隐藏的-Boss" class="headerlink" title="隐藏的 Boss"></a>隐藏的 Boss</h2><p>就像动漫钢之炼金术师里烧瓶中的小人一样，有时候最危险的人物或者说最终的 Boss 可能就隐藏在你身边，甚至可能是你最忠实的奴仆。在单测中，需要我们随时注意不被反咬一口的就是 Mocking。</p><p>###MockingJay</p><h2 id="Happy-Path-vs-Unhappy-Path"><a href="#Happy-Path-vs-Unhappy-Path" class="headerlink" title="Happy Path vs. Unhappy Path"></a>Happy Path vs. Unhappy Path</h2><h2 id="Rx，你个磨人的小妖精"><a href="#Rx，你个磨人的小妖精" class="headerlink" title="Rx，你个磨人的小妖精"></a>Rx，你个磨人的小妖精</h2><p>双生<br>RxTest<br>Rxblocking</p><h3 id="RxTest-VS-RxBlocking"><a href="#RxTest-VS-RxBlocking" class="headerlink" title="RxTest VS. RxBlocking"></a>RxTest VS. RxBlocking</h3><p>两个在 Rx 的测试中都非常有用，RxBlocking 更加直观，RxTest 更加全面。</p><p>RxTest 可以覆盖大部分测试，而且 TestScheduler 模拟的虚拟时间可以大大缩短测试时间，但是写起来比较长也比较麻烦</p><p>相比 RxBlocking 写起来非常简单也直观，但使用场景比较局限，其中对我们来说比较致命的一点是 RxBlocking 对于无法停止的序列的测试能力很有限，并不能提供我们需要的能力。而我们直播中大部分序列都是无限序列，所以暂时不考虑 RxBlocking。</p><p>还有一点就是，RxBlocking 无法测试时间相关的用例，比如我在 1s的时候收到一个信号，想测试输出是否在 1s的时候输出某个特定值，RxBlocking 只能测试出来收到了这个值，但是不能确定时间戳。RxBlocking 比较适合测试初始值，或者只有一个状态的序列。</p><p>RxBlocking 也会 block 住当前线程，所以之前发生过的，测试走到 RxBlocking的语句之后，就会卡死并且无法继续进行测试也是这个引起的（我们使用了 BehaviorRelay 是无限序列）。</p><p>所以之后的测试还是需要继续使用 RxTest，以上。</p><div class="note info"><p>相关链接：</p><p><a href="https://github.com/Quick/Quick/tree/master/Documentation" target="_blank" rel="noopener">Quick Documentation</a><br><a href="https://www.raywenderlich.com/135-behavior-driven-testing-tutorial-for-ios-with-quick-nimble#toc-anchor-010" target="_blank" rel="noopener">Behavior-Driven Testing Tutorial for iOS with Quick &amp; Nimble</a><br><a href="http://rx-marin.com/post/rxblocking-part2/" target="_blank" rel="noopener">Testing with RxBlocking, part 2</a><br><a href="https://www.raywenderlich.com/7408-testing-your-rxswift-code#toc-anchor-005" target="_blank" rel="noopener">Testing Your RxSwift Code</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷二），本系列链表头部请戳 &lt;a href=&quot;https://cyberhex.me/2020/06/14/tdd-part-one/&quot;&gt;A song of TDD and BUG - 前奏曲&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 04</title>
    <link href="http://cyberhex.me/2020/07/05/arts-04/"/>
    <id>http://cyberhex.me/2020/07/05/arts-04/</id>
    <published>2020-07-05T15:36:17.000Z</published>
    <updated>2020-07-05T16:57:40.748Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>前缀树问题（LeetCode 208 中等）</p><p>这个问题也相当于一个比较基础的问题了，它是一些其他题目（比如 Word ladder II 之类的）题目的前置题目，这个题目如果你是想刷算法的话属于必背题目，核心点是在每次插入一个单词的时候更新树的结构，这样的话在下次查找的时候就可以判断是否有这个单词或者是否有以某个单词开头的单词。</p><p>一个比较重要的点就是前缀树和哈希表之间的对比，他们俩在很多时候可以互相替代，前缀树花费的空间更少一些但是单次查询花费的时间更多一点。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>前一阵做单元测试的时候发现一个问题，就是如果想把 UIImage 作为 ViewModel 的输出的时候会有一个问题就是不知道怎么样单测这个 UIImage 的输出，最后无奈只能让 ViewModel 输出 UIImage 的名字，然后在 ViewController 中来进行 UIImage 的初始化。但是昨天看关于单测的东西的时候发现一个很好用的技巧，下次在做单测的时候可以尝试使用了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testImage</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> viewModelImage = viewModel.image</span><br><span class="line"><span class="keyword">let</span> viewModelImageDataReference = viewModelImage.pngData()!</span><br><span class="line"><span class="keyword">let</span> stubImageDataReference = <span class="type">UIImage</span>(named: <span class="string">"test"</span>).pngData()!</span><br><span class="line"><span class="type">XCAssertEqual</span>(viewModelImageDataReference, stubImageDataReference)</span><br><span class="line"><span class="type">XCAssertEqual</span>(viewModelImage.size.width, desiredWidth)</span><br><span class="line"><span class="type">XCAssertEqual</span>(viewModelImage.size.height, desiredHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://cyberhex.me/2020/07/05/unit-test-short-story-01/">尤尼泰斯特 2020 - 回忆篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 03</title>
    <link href="http://cyberhex.me/2020/07/05/arts-03/"/>
    <id>http://cyberhex.me/2020/07/05/arts-03/</id>
    <published>2020-07-05T10:45:12.000Z</published>
    <updated>2020-07-05T17:05:43.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;h2 id=&quot;Review&quot;&gt;&lt;a href=&quot;#Review&quot; class=&quot;head
      
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 02</title>
    <link href="http://cyberhex.me/2020/07/05/arts-02/"/>
    <id>http://cyberhex.me/2020/07/05/arts-02/</id>
    <published>2020-07-05T09:41:11.000Z</published>
    <updated>2020-07-05T17:00:59.722Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a><br>二三周的打卡因为工作和家里的原因耽误了，这两个礼拜就会补上</p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>A song of TDD and BUG - 前奏曲</title>
    <link href="http://cyberhex.me/2020/06/14/tdd-part-one/"/>
    <id>http://cyberhex.me/2020/06/14/tdd-part-one/</id>
    <published>2020-06-14T09:41:34.000Z</published>
    <updated>2020-07-19T16:06:58.189Z</updated>
    
    <content type="html"><![CDATA[<p>TDD 与 BUG 的爱恨情仇（卷一）<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是最好的时代，TDD 的出现终结了 BUG 横行的蛮荒，从此 Coding 世界进入了秩序与光明；这也是最坏的时代，历史的包袱，无尽的重构，博弈与妥协充斥在每个角落。从电脑和编程出现之初 Bug 就如影随形，那只飞到 Mark II 上的 Bug 穿越了大半个世纪，仍是程序员们在梦中惊醒，在镜前流泪的主要原因。那 Bug 为什么会出现？有没可能消除 Bug？ 这是个哲学问题。</p><h2 id="Bug的相对性原理"><a href="#Bug的相对性原理" class="headerlink" title="Bug的相对性原理"></a>Bug的相对性原理</h2><p>有人说 Bug 是一个 Human Error，是可以通过一定的约定，准则和谨慎去避免的。的确, Bug 的多少很大程度上是程序员的谨慎程度来决定的。但是，我先把我的结论放在这， Bug 是无法避免的，也就是说他是一个在排除了人为错误之外的系统性的存在。这听起来很像给自己开脱（其实就是给自己开脱），但是我是有理（狡）论（辨）支持的。比如之前有人提出来过抽象漏洞定律来解释这个问题，但是这个太笼统，听起来也太抽象，我想用自己的理解来解释一下。首先我们需要定义 Bug 是什么，维基百科中 Bug 的定义是程序错误。我们在这给它一个更明确，更有意义的定义，就是： Bug 是程序中与预期情况表现不符合的逻辑。比如：产品让我点击购买键下单，我写成了点击购买键弹窗嘲讽用户买不起。这就是一个 Bug。从上边的例子里我们可以发现，之前定义中的预期是需要参照物的，而这个参照物是什么，这才是真正的 tricky part。如果这个参照物值得是所有人的预期表现，那这个问题就好回答了，每个人或者说至少有一些的对不同同一个功能有不同的预期，这样的话在一些人看来正常的代码，在另一些人看来就是 Bug，这就是 Bug 的相对性。而如果这个参照物是指的产品需求，这可能就需要一番解释了。在这里我想引入两个概念：需求的时间局部绝对正确性和需求的绝对进化性。听起来很 fancy，其实很简单（你不小心发现了程序员术语的真相）。需求的时间局部绝对正确性是指一个需求在下一次需求到来之前是具有绝对的权威性的，需求的绝对进化性是指两个相邻需求之间是至少有一处不同的。了解了这两个概念，后边的推理就简单多了。使用数学归纳法，假设上一个代码和需求是完全符合的，在下一个需求到来的时候，根据需求的时间局部绝对正确性，这时候具有绝对正确性的需求是新来的需求，而又由于需求的绝对进化性，新需求和上一个需求之间至少有一处不同，也就是现在的代码至少有一处跟新需求不同，根据 Bug 的定义，也就是至少有一个 Bug。有人会说，那假设我不变需求不就是不会有这种 Bug 了吗，可别忘了，从无到有也是一种情况。这个本来就是一个很有争议的问题，有什么想法也可以在评论区一起讨论。</p><h2 id="程序员的千层饼理论"><a href="#程序员的千层饼理论" class="headerlink" title="程序员的千层饼理论"></a>程序员的千层饼理论</h2><p>听了我瞎扯了这么久，你可能在想这人到底想说个啥。我其实想表达的是 Bug 如风，常伴吾身，我们要学会去与之共存。但是与之同存并不是对其容忍（skr），我们的先辈们披荆斩棘为我们探索出了很多路，其中一条非常亮眼的就叫单元测试。作为程序员对单测有一定了解或者至少有所耳闻，但大部分对自己对于单测的认知多多少少都有一些障碍。在这里我就想借鉴一下 LOL 直播界的哲学家大司马老师的千层饼理论来阐述我的观点。对于单测，很多程序员都认为自己看到了第五层，觉得自己在第二层，其实自己是在第一层，像我这种马虎点的甚至都在地下一层。那这里边的第几层分别代表什么呢。第五层代表不写任何种类的测试就能做到杜绝人为的 Bug，第二层代表会写单测就是懒得写而已，第一层代表并不会写单测，而地下一层代表不但不会写单测而且只会写 Bug。你品，你细品，自己属于第几层。</p><h2 id="你不愿写单测的原因"><a href="#你不愿写单测的原因" class="headerlink" title="你不愿写单测的原因"></a>你不愿写单测的原因</h2><p>不愿写单测的原因有千千万，但是大体可以分为以下三类：</p><ol><li>业务都写不完，哪来的时间弄这破玩意</li><li>已经有测试了，没有必要浪费时间去写单测，我还要追求诗和远方</li><li>业务逻辑太简单了，我就是人形单测</li></ol><h2 id="单测的重要性"><a href="#单测的重要性" class="headerlink" title="单测的重要性"></a>单测的重要性</h2><p>其实我之前跟其他人一样也会有很多的顾虑（其实是懒），之前看一些教程如果碰到关于单测的部分我都是跳过或者边看视频边“学”完，但是在工（被）作（迫）需（无）要（奈）之下我开始接触关于单测和 TDD 的东西，现在可以说是单测最忠实的追随者了。现在我就替你来一一打消上边提到的所有顾虑。</p><ol><li>关于第一点顾虑：没有时间。只要你跟着这个系列教程，会让你对单测有更深的了解，至少会带你入门并且写出第一个单测，你就想像我这么懒的人都能学会，你凭什么学不会。</li><li>关于第二点顾虑，我主要想分成两部分来分析 - “有测试” 和 “浪费时间”：<ul><li>有测试：团队内的 QA 所做的测试都是黑盒测试，也就是他们只能告诉你现象，更好一点告诉你复现的具体步骤，有经验的测试可能会告诉你他们的猜测。但是猜测毕竟只是猜测，你还是需要一步一步去调试，去寻找 Bug 的根源。但是如果是单测跑失败了，你只需要看一眼单测的名字，就可以基本上定位到问题所在了。</li><li>浪费时间：上一点已经有一点涉及到节省时间了，但是这还不够。我们做一个项目，一般都不是只做一版不需要迭代，也免不了重构。只要是需要迭代或者重构，就有单测发挥优势的机会，因为在这些过程中所产生的副作用，比如对之前逻辑的影响，都会由之前的单测来保证，这会很大程度上节省我们排查旧逻辑的时间。        </li></ul></li><li>关于第三点顾虑，业务逻辑简单是相对的，对于你来说，旧逻辑都是你写的或者是你维护的，但是对于新来的同事，他们可能就会一头雾水，需要一段时间去了解业务，但是如果有单测（BDD 更好，这里挖个坑，以后填），通过看单测，他/她就会对业务有个大概了解，对于之后的工作有很大的帮助。</li></ol><h2 id="什么是-TDD"><a href="#什么是-TDD" class="headerlink" title="什么是 TDD"></a>什么是 TDD</h2><p>再声明一遍，不是 PDD，不是 SSD，更不是 PTSD。下边我们有请开发模式界最耀眼的新星，不健壮代码的救世主，莫得感情的 Bug 收割机器 - T·听起来就很炫酷·DD。TDD 的全称是 Test-Driven Development，翻译过来就是测试驱动开发。它是敏捷开发的一项实践和技术，它背后的行为哲学就是以测试为导向进行项目的开发。</p><p>它有四个步骤：</p><ol><li>写一个失败的单元测试</li><li>完善代码让测试通过</li><li>重构</li><li>重复上述步骤到天荒地老</li></ol><p>听起来感觉就很繁琐的样子，其实并没有想象的那么麻烦，后边会进行进一步的解释。</p><h2 id="赛博朋克演示法"><a href="#赛博朋克演示法" class="headerlink" title="赛博朋克演示法"></a>赛博朋克演示法</h2><p>本系列我会继续使用我最喜欢的赛博朋克演示法，那有同学就要问了，什么是赛博朋克演示法呢？其实大家都在写博客或者做分享的时候用到过，只不过这个方法被我冠名成赛博朋克演示法，我还没有看到其他人这么叫过，所以算原创吧（小得意一下）。</p><p>众所周知，所谓赛博朋克就是高科技，低生活。那套用在这里就是用一个特别傻的项目去演示一个特别 fancy 的概念。所以贯穿整个系列我都会用一个天气的项目叫做 <a href="https://github.com/quintessencegpy/Rainstorm" target="_blank" rel="noopener">Rainstorm</a> 来展示单测和 TDD 的概念，这个项目不是我的原创，是我在学习 MVVM 的时候跟着 <a href="https://cocoacasts.com/" target="_blank" rel="noopener">cococast.com</a> 一起做的，这个不是广告，只是既然用了人家的东西，总得给人家一个名分，嗯嗯。</p><p>如果你对我说的这些都感兴趣，那就跟着我的节奏一起摇摆（不好意思，走错片场了），跟着我的步伐一起深入了解 TDD，欢迎观看下一集 <a href="https://cyberhex.me/2020/07/07/tdd-part-two/">A song of TDD and BUG - 主歌</a>。</p><div class="note info"><p>相关链接：</p><p><a href="https://kknews.cc/zh-hk/code/qx5639g.html" target="_blank" rel="noopener">為什麼任何系統都會存在Bug？什麼是抽象漏洞定律？</a><br><a href="https://blog.gurock.com/unit-testing-tdd-bdd/?utm_source=adwords&amp;utm_medium=cpc&amp;utm_campaign=asia_afr_ams_en_dsa&amp;utm_content=&amp;creative=302597526479&amp;keyword=&amp;matchtype=b&amp;network=g&amp;device=c&amp;gclid=CjwKCAjwmMX4BRAAEiwA-zM4JryMT8iAqgeNEpB6mdo1aCOXYdR-EOIEADy8R1eG20r5vvgv7lelfhoCDDYQAvD_BwE" target="_blank" rel="noopener">Unit Testing, TDD, and BDD, Oh My. Your Guide to Different Unit Testing Techniques</a><br><a href="http://www.51testing.com/html/00/n-3724000.html" target="_blank" rel="noopener">论单元测试的重要性</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TDD 与 BUG 的爱恨情仇（卷一）&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="TDD" scheme="http://cyberhex.me/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>ARTS 打卡 01</title>
    <link href="http://cyberhex.me/2020/06/14/arts-01/"/>
    <id>http://cyberhex.me/2020/06/14/arts-01/</id>
    <published>2020-06-14T09:41:11.000Z</published>
    <updated>2020-07-05T16:57:43.466Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是公司内部 ARTS 活动打卡记录<br><a id="more"></a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>N 皇后问题（LeetCode 51 困难）</p><p>这个题目也算是 DFS 算法中经典的经典，所以这道题目的结构也是遵循递归的几大步骤（recursion terminator，current level logic，drill down，reverse state if needed），只不过这道题目需要多考虑的是怎么剪枝，也就是如果提前发现本次递归是一个无效的递归就提前终止。我的做法是用了三个 set 来记录当前的位置是否有效，我看讨论区还有一种用位运算来处理的，看起来很 fancy，但是没有仔细去研究，有时间需要好好看一下。</p><p>DFS 一直感觉有一点烧脑，尤其是如果做人肉递归的情况下，以后要养成避免人肉递归的习惯。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>最近一直在看 Raywenderlich 的 RxSwift 的书，已经看到了第 24 章（总共 25 章 fighting！），感觉收获很大，好好反思了之前对于 RxSwift 的用法，觉得有很多不合理的地方，而且也有了一些在工作上该如何使用的思考，顺便思考了之前项目中的架构的不足，由于最近开始折腾单测的问题才发现之前有很多不合理的地方，在之后的重构中要更加注意。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>本来以为这周的 tips 可能要鸽了，但是在打卡前的最后几个小时发现了一个看起来很有意思的小技巧，让我这个强迫症眼前一亮。<br>在 MVVM 中因为每一个 ViewController 都会有一个 ViewModel，所以之前我在创建 ViewController 的时候有两种方法，一种是用 Initializer Injection，也就是把 ViewModel 作为 ViewController的 Init 方法的参数，另一种就是把 ViewModel 设为一个 Optional 的 internal 的变量，在初始化 ViewController 之后把 ViewModel 赋值进去。但感觉这两种方法都有一点不符合我的习惯，第一种需要加一个没用的 required 的 initializer，第二种需要在初始化之后赋值（有可能会忘）。今天发现一种使用工厂方法来创建 ViewController 的套路，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> viewModel: <span class="type">ViewModel</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(withViewModel viewModel: ViewModel)</span></span> -&gt; <span class="type">ViewController</span> &#123;</span><br><span class="line"><span class="keyword">let</span> vc = <span class="type">ViewController</span>()</span><br><span class="line">vc.viewModel = viewModel</span><br><span class="line"><span class="keyword">return</span> vc</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://cyberhex.me/2020/04/26/coodinator-pattern/">都是 Apple 惹的祸 - Coordinator Pattern 的前世今生</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是公司内部 ARTS 活动打卡记录&lt;br&gt;
    
    </summary>
    
      <category term="ARTS" scheme="http://cyberhex.me/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>跨端开发的终极解决方案？- Flutter 学习历程之环境配置采坑记录</title>
    <link href="http://cyberhex.me/2020/05/16/flutter-setup/"/>
    <id>http://cyberhex.me/2020/05/16/flutter-setup/</id>
    <published>2020-05-16T11:50:41.000Z</published>
    <updated>2020-06-14T11:07:44.290Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在设置 Flutter 环境时的心路历程。<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在设置 Flutter 环境时的心路历程。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://cyberhex.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Flutter" scheme="http://cyberhex.me/tags/Flutter/"/>
    
      <category term="Dart" scheme="http://cyberhex.me/tags/Dart/"/>
    
      <category term="Setup" scheme="http://cyberhex.me/tags/Setup/"/>
    
  </entry>
  
  <entry>
    <title>都是 Apple 惹的祸 - Coordinator Pattern 的前世今生</title>
    <link href="http://cyberhex.me/2020/04/26/coodinator-pattern/"/>
    <id>http://cyberhex.me/2020/04/26/coodinator-pattern/</id>
    <published>2020-04-26T09:39:41.000Z</published>
    <updated>2020-06-14T11:02:17.519Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在学习 Coordinator Pattern 是的心得。<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近工作中需要对一个升级 B 端的项目，本来只是更新 UI，对 H5 进行支持的简单工作，但是我灵机一动（用大脑一抽可能更好一点），决定对项目进行一次重构，目标 MVVM-C。对于 MVVM 可能大家了解的比较多，但是后边那个小 C 是什么可能有些小朋友并不是特别清楚。这种时候，从小就开始训练的阅读理解能力就派上用场了，看一眼文章题目你就知道这个 C 代表什么了。什么？ CyberHex？虽然我很开心，但是我替你们的语文老师伤心三秒，1，2，3，好了。其他人应该都猜对了，对！就是 Coordinator。那到底什么 Coordinator 的设计模式？它是怎么产生的？它解决了什么痛点？接下来我就带大家走进 Coordinator 的内心，从而对它有一个更深的了解。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从文章题目“都是 Apple 惹的祸”你可能已经看到了一些问题的端倪，没错，Coordinator Pattern 的出现就是为了弥补苹果在设计 UIKit 的时候的一些疏忽（不知道是有意还是无意的）。多年前一个风雨交加，电闪雷鸣的夜晚，UIKit 带着全村人的希望诞生了，谁都不知道它的出现将改变移动端的整个未来，更没有人想到的是，在风光无限的背后，是一个致命的（？）生理缺陷，而这个缺陷也将为它带来巨大的危机。而就是到了那时，一个叫 Coordinator 的盖世英雄将踩着七色云彩来解救它。好了，不瞎扯了，我觉得我的水平不去 UC 当编辑真的是屈才了。 其实在很早的时候就有人发现了 UIKit 的这个缺陷并试图去解决它，最早有 <a href="https://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">Soroush Khanlou</a> 的尝试，到现在 Coordinator 已经是一个比较成熟的 iOS 设计模式了，并且和 MVVM 经常同框出镜，人们称这对好基友组合为 MVVM-C。现在就要有人说了，卖了这么多关子，到底它解决了哪些问题。别着急，接下来胡扯环节结束，上干货。</p><h2 id="UIKit-的内在问题和-Coordinator-的解决方法"><a href="#UIKit-的内在问题和-Coordinator-的解决方法" class="headerlink" title="UIKit 的内在问题和 Coordinator 的解决方法"></a>UIKit 的内在问题和 Coordinator 的解决方法</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在学习 Coordinator Pattern 是的心得。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://cyberhex.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://cyberhex.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Design Pattern" scheme="http://cyberhex.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>优化图片</title>
    <link href="http://cyberhex.me/2019/06/26/optimizing-images/"/>
    <id>http://cyberhex.me/2019/06/26/optimizing-images/</id>
    <published>2019-06-25T16:39:37.106Z</published>
    <updated>2020-06-14T11:02:02.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jordan Morgan，<a href="https://www.swiftjectivec.com/optimizing-images/" target="_blank" rel="noopener">原文链接</a>，原文日期：2018-12-11<br>译者：CyberHex；</p></blockquote><p>人们常说你手里的相机就是最好的那个。如果俗语能说明一些问题的话，那么毫无疑问，iPhone 完全就是这个星球上最重要的相机。而且整个行业也证明了这件事。</p><p>出去度假了？不给你的 Instagram 上传几张照片顺便在手机里存几张备用的都不太可能。</p><p>又出了个大新闻？翻翻微博查看有关这个事件的图片就可以实时掌握有哪些渠道在播报这件事。</p><p>例子数不胜数。</p><p>但是尽管图片无处不在，想用一种既能保持高性能又不消耗很多内存的方式来展示这些图片还真得多费点劲。只要了解了 UIKit 中发生了什么，并且理解了它如何处理图片，我们就可以节省一大笔内存同时还能免去想砸键盘的冲动。</p><h2 id="讲一点理论"><a href="#讲一点理论" class="headerlink" title="讲一点理论"></a>讲一点理论</h2><p>先出一个脑筋急转弯：下面这张我女儿非常潮的照片有 266KB，猜一下它在 iOS 应用中需要占多少内存？</p><p><img src="https://www.swiftjectivec.com/assets/images/baylor.jpg" alt="Photo of dauther"></p><p>剧透警告：不是 266k，也不是 2.66M，而是 14M。</p><p>怎么会这样？</p><p>iOS 在得出内存使用的时候基于的是图片的维度，而图片真正的大小跟内存没有几毛钱关系。这张图片的维度是 1718 像素宽，2048像素高。假设每个像素占用四个字节内存：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1718</span> * <span class="number">2048</span> * <span class="number">4</span> / <span class="number">1024</span> / <span class="number">1024</span> = 大约 <span class="number">13.42</span> <span class="type">MB</span></span><br></pre></td></tr></table></figure><p>假设你有一个包含一堆用户的 table view，每一行都在左上角用如今最流行的圆形来展示他们的头像。如果你觉得这没什么，因为这些图片已经用 ImageOptim 或者相似的东西压缩过了，那你就大错特错了。假设每个图片是 256x256 的话，这样还是会占掉不少的内存。</p><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>通过上边的例子，我们可以得出：了解渲染图片的机制也非常重要。当你载入一个图片，会有下边三个步骤：</p><p>1.载入：iOS 把压缩后的图片（在我们的例子中 266KB）放入内存中。这一步中并没有什么需要特别注意的。<br>2.解码：接下来，iOS 把图片转化为 GPU 可以理解和读取的形式。这一步中图片已经不是压缩状态了，现在就到了我们上边说的 14MB。<br>3.渲染：就像步骤名所说的一样，图片数据已经能够以任意形式被渲染到屏幕上，就算只是一个 60*60 那么小的 image view。</p><p>解码过程算一个比较重要的阶段。在这个过程中 iOS 会创建一个缓存区（准确的来说是一个图片缓存区），它是图片在内存中的表现形式。这就很好的解释了为啥这个缓冲区的大小本质上是和图片的面积而非文件大小挂钩的。从而也清楚的描绘了在计算图片的内存消耗时为什么图片的维度这么重要。</p><p>对于 UIImage 来说，当我们塞给他的不论是从网络请求或者是其他途径里得到的图片数据，它都会把这些数据缓存解析为数据中所要求的任何压缩形式（比如 PNG 或者 JPG）。但是，这些数据其实还是会继续存在，因为渲染不是一个只会进行一次的操作，所以 UIImage 会把图片缓存保存下来，确保它只被解析一次。</p><p>现在我们发散一下思维：一个可以适用于任何 iOS 应用的完整缓存区就是它的帧缓存区。当你的应用要出现在屏幕上时，帧缓存区把它真正的显示出来，因为缓存区里有需要被显示出来内容的渲染结果。任何 iOS 设备的显示硬件都可以利用这些像素信息把这些像素展现在屏幕上。</p><p>在这种情况下，时长就会影响结果。想得到 60 帧每秒的行云流水般的滑动，帧缓存区就需要让 UIKit 渲染应用的窗口，并且需要当子视图的信息有变化时（比如给 image view 添加图片），所有子视图都加到窗口上边。如果这一步完成的太慢的话，就会丢帧。</p><blockquote><p>你觉得六十分之一秒已经很短了？想象一下，有 Pro Motion 技术的设备会把这个数字提到一百二十分之一秒。</p></blockquote><h2 id="尺寸很重要"><a href="#尺寸很重要" class="headerlink" title="尺寸很重要"></a>尺寸很重要</h2><p>我们可以很容易的对这个过程和过程中的内存使用进行可视化。就用之前我女儿的那张照片，我创建了一个很简单的应用，里边有一个 image view 来展示这张照片：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">NSURL</span>(fileURLWithPath: filePath)</span><br><span class="line"><span class="keyword">let</span> fileImage = <span class="type">UIImage</span>(contentsOfFile: filePath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image view</span></span><br><span class="line"><span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(image: fileImage)</span><br><span class="line">imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">imageView.contentMode = .scaleAspectFit</span><br><span class="line">imageView.widthAnchor.constraint(equalToConstant: <span class="number">300</span>).isActive = <span class="literal">true</span></span><br><span class="line">imageView.heightAnchor.constraint(equalToConstant: <span class="number">400</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">view.addSubview(imageView)</span><br><span class="line">imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>在实际工作中不要使用强行解包，这个例子比较简单，所以才小用一下。</p></blockquote><p>我们会得到如下结果：</p><p><img src="https://www.swiftjectivec.com/assets/images/baylorPhone.jpg" alt="Photo of dauther"></p><p>迅速去 LLDB 上瞄一眼就可以发现，就算我们用一个更小的 image view 来展示这张图，它的维度还是原来那样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="type">UIImage</span>: <span class="number">0x600003d41a40</span>&gt;, &#123;<span class="number">1718</span>, <span class="number">2048</span>&#125;</span><br></pre></td></tr></table></figure><p>注意哟，这里可是用点来表示的。也就是说，如果我在用一个 3x 或者是 2x 的设备，有可能还会得到一个是这个倍数的数字。接下来我们转战去 vmmap，看我们能不能确认这张图用了 14MB 的内存：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmmap --summary baylor.memgraph</span><br></pre></td></tr></table></figure><p>下边几项数据比较亮眼：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Physical</span> footprint:         <span class="number">69</span>.5M</span><br><span class="line"><span class="type">Physical</span> footprint (peak):  <span class="number">69</span>.7M</span><br></pre></td></tr></table></figure><p>现在有将近 70M 的内存使用，也给了我们一个重构代码的基准。如果我们集中再看看我们图片的内存消耗：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmmap --summary baylor.memgraph | grep <span class="string">"Image IO"</span></span><br><span class="line"></span><br><span class="line"><span class="type">Image</span> <span class="type">IO</span>  <span class="number">13</span>.4M   <span class="number">13</span>.4M   <span class="number">13</span>.4M    0K  0K  0K   0K  <span class="number">2</span> </span><br></pre></td></tr></table></figure><p>啊嘞嘞，内存里有大约 14MB 的脏内存。这跟我们当时估算的图片的大小一样。为了充实论点，下边我给出了一张截图可以清晰的看出每一行的消耗，因为这是使用 grep 查到的。</p><p><img src="https://www.swiftjectivec.com/assets/images/vmmap.jpg" alt="Snapshot of grepin"></p><p>所以很明显，现在我们在一个 300 x 400 的 image view 上使用了原图所占的内存大小。图片的大小很重要，但是这不是唯一影响内存消耗的因素。</p><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><p>你所请求使用的一部分内存是由另一个重要因素色域所决定的。在上边的例子中，我们做了一个在大部分 iPhone 中并不成立的假设，就是图片使用的是 sRGB 格式。一个像素点有4个字节是因为给了红、蓝、绿和透明度各一个字节。</p><p>如果你用一个支持非常广色域的手机（不如 iPhone 8P 或者 iPhone X）来拍照，你很有可能会使用双倍的内存。当然，倒过来也是对的。Metal 可以使用 Alpha 8 的格式，这种格式就跟它名字所暗示的那样，只用一个维度（透明度）。</p><p>这里边有好多需要考虑和操作的东西。这就是为什么我们要用 <a href="https://www.swiftjectivec.com/uigraphicsimagerenderer/" target="_blank" rel="noopener">UIGraphicsImageRender</a> 而不是用 UIGraphicsBeginImageContextWithOptions，后者总是会使用 sRGB，也就是说在你想用<a href="https://instagram-engineering.com/bringing-wide-color-to-instagram-5a5481802d7d" target="_blank" rel="noopener">更广的色域</a>的时候无法使用它们，或者在你想选择较小色域的时候没法节省内存。在 iOS 12 以后，UIGraphicsImageRender 会帮你选择最合适的那一个。</p><p>这里再提一嘴，免得过会再忘了，很多我们截的图片其实并不是拍摄类型，而仅仅是简单的绘图操作。并不是说想重提我前一阵写过的东西，但是以防你之前没看过：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> circleSize = <span class="type">CGSize</span>(width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UIGraphicsBeginImageContextWithOptions</span>(circleSize, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画个圈圈</span></span><br><span class="line"><span class="keyword">let</span> ctx = <span class="type">UIGraphicsGetCurrentContext</span>()!</span><br><span class="line"><span class="type">UIColor</span>.red.setFill()</span><br><span class="line">ctx.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">ctx.addEllipse(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line">ctx.drawPath(using: .fill)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circleImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line"><span class="type">UIGraphicsEndImageContext</span>()</span><br></pre></td></tr></table></figure><p> 上边这个圆形图像使用的是每个像素 4 个字节的格式。如果使用 UIGraphicsImageRender 的话，它会自动帮你选择最合适的格式来渲染，这样你在全部选用每像素 1 个字节的格式的情况下最多能节省 75% 的内存。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> circleSize = <span class="type">CGSize</span>(width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"><span class="keyword">let</span> renderer = <span class="type">UIGraphicsImageRenderer</span>(bounds: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circleImage = renderer.image&#123; ctx <span class="keyword">in</span></span><br><span class="line">    <span class="type">UIColor</span>.red.setFill()</span><br><span class="line">    ctx.cgContext.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">    ctx.cgContext.addEllipse(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line">    ctx.cgContext.drawPath(using: .fill)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="缩放-VS-降采样"><a href="#缩放-VS-降采样" class="headerlink" title="缩放 VS. 降采样"></a>缩放 VS. 降采样</h2><p>先把刚才那个简单的绘图的例子放在一边，其实大部分与图片相关会影响内存使用的问题都源自于那些现实生活中人们摄影的照片。包括用 portraits 和 landscape 拍出来的照片和一些其他的照片。</p><p>这也证明了为什么一些程序猿们会觉得用 UIImageView 进行图片缩放就够使了。但是 UIImageView 的问题一般不是因为上边所罗列出来的原因，而且根据苹果大神 Kyle Howarth 的说法，它性能不好是因为内部坐标的转换。</p><p>在这种情况下，UIImage 会影响效率的一个主要原因是它会按照我们之前在渲染管线中讨论过的那样把原始图片压缩进内存中。而在理想情况下，我们需要想个办法来减少图片缓存区的大小。</p><p>庆幸的是，只用被缩放后图片所消耗的内存来调整图片大小是有可能的，这也是为什么好多人会以为这个是在缩放图片时的默认行为。然而实际情况并不是这样。</p><p>我们现在尝试换成底层的 API 来进行缩放：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(url, <span class="literal">nil</span>)!</span><br><span class="line"><span class="keyword">let</span> options: [<span class="type">NSString</span>:<span class="type">Any</span>] = [kCGImageSourceThumbnailMaxPixelSize:<span class="number">400</span>,</span><br><span class="line">                            kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> scaledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options <span class="keyword">as</span> <span class="type">CFDictionary</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(image: <span class="type">UIImage</span>(cgImage: scaledImage))</span><br><span class="line">    </span><br><span class="line">    imageView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    imageView.contentMode = .scaleAspectFit</span><br><span class="line">    imageView.widthAnchor.constraint(equalToConstant: <span class="number">300</span>).isActive = <span class="literal">true</span></span><br><span class="line">    imageView.heightAnchor.constraint(equalToConstant: <span class="number">400</span>).isActive = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    view.addSubview(imageView)</span><br><span class="line">    imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">    imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>我们会得到和以前一样的结果。但是这次，我们用的是听起来就有逼格的 CGImageSourceCreateThumbnailAtIndex() 而不是简单得把图片丢给 image view 来处理。又一次，我们这次优化是否有效的真相就藏在 vmmap 中（为了简便就做了四舍五入）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmmap -summary baylorOptimized.memgraph</span><br><span class="line"></span><br><span class="line"><span class="type">Physical</span> footprint:         <span class="number">56</span>.3M</span><br><span class="line"><span class="type">Physical</span> footprint (peak):  <span class="number">56</span>.7M</span><br></pre></td></tr></table></figure> <p>我们已经能看到省了不少内存。如果和之前的 69.5MB 相比，56.3MB 足足少了 13.2MB。这是一笔很大的节省，几乎相当于整张图片的消耗。</p><p>接下来，有很多选择能让你在不同的情况下去做尝试。在 WWDC 18的会议 219 “图像和图形的最好实践”中，苹果公司的工程师 Kyle Sluder 给我们展示了一个非常有趣的方法 - 使用 kCGImageSourceShouldCacheImmediately 标识位来控制解析过程：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downsampleImage</span><span class="params">(at URL:NSURL, maxSize:Float)</span></span> -&gt; <span class="type">UIImage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sourceOptions = [kCGImageSourceShouldCache:<span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> source = <span class="type">CGImageSourceCreateWithURL</span>(<span class="type">URL</span> <span class="keyword">as</span> <span class="type">CFURL</span>, sourceOptions)!</span><br><span class="line">    <span class="keyword">let</span> downsampleOptions = [kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">                            kCGImageSourceThumbnailMaxPixelSize:maxSize</span><br><span class="line">                            kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">                            kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">                            ] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> downsampledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(source, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>在上边的函数中，Core Graphics 会在你想要缩略图的特定时刻才会进行解析。 注意要像我们之前的那两个例子中一样加入 kCGImageSourceCreateThumbnailMaxPixelSize 的变量，因为如果你不加的话，你得到的缩略图会和原图一样大。文档中这样说：</p><blockquote><p>“如果不指定像素大小上限的话，缩略图就会跟原图一样大，你肯定不想看到这样的结果”</p></blockquote><p>所以发生了什么？简单的说，就是我们通过在缩放阶段使用缩略图从而创建了一个比以前小很多的解析图片缓存区。现在回头想想我们的渲染管线，第一步（载入）中我们丢给 UIImage 一个只包含我们要展示的图片的图片缓存区，而不是传入相当于整个图片维度的缓存区让它去解析。</p><p>如果你想用一秒钟来读完这篇文章的话就记住一句话。有机会的话一定要用降采样而不是使用 UIImage 的缩放来处理图片。</p><h2 id="彩蛋时间"><a href="#彩蛋时间" class="headerlink" title="彩蛋时间"></a>彩蛋时间</h2><p>我个人喜欢把上边的方法和 iOS 11 以后引入的 <a href="https://developer.apple.com/documentation/uikit/uitableviewdatasourceprefetching?language=swift" target="_blank" rel="noopener">prefetch API</a> 放在一起用。要记住，因为我们要在 table view 或者 collection view 显示 cell 之前解析图片，所以我们很容易不知不觉的就引入 CPU 峰值。</p><p>因为 iOS 非常擅长在有稳定电量需求的情况下管理电量使用，但是在这种情况下电量需求是断断续续的，所以是时候让我们自己写的队列来展示真正的技术了。这样做也会把解析过程放在背景线程中，一石二鸟啊。</p><p>捂上你的双眼，别被下边我的小项目里的 OC 的代码亮瞎了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用你自己写的队列而不是 global async 可以避免线程崩溃</span></span><br><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView prefetchRowsAtIndexPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downsampledImage != <span class="literal">nil</span> || </span><br><span class="line">        <span class="keyword">self</span>.listItem.mediaAssetData == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *mediaIndexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="number">0</span></span><br><span class="line">                                                     inSection:SECTION_MEDIA];</span><br><span class="line">    <span class="keyword">if</span> ([indexPaths containsObject:mediaIndexPath])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> scale = tableView.traitCollection.displayScale;</span><br><span class="line">        <span class="built_in">CGFloat</span> maxPixelSize = (tableView.width - SSSpacingJumboMargin) * scale;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.downsampleQueue, ^&#123;</span><br><span class="line">            <span class="comment">// Downsample</span></span><br><span class="line">            <span class="keyword">self</span>.downsampledImage = [<span class="built_in">UIImage</span> downsampledImageFromData:<span class="keyword">self</span>.listItem.mediaAssetData</span><br><span class="line">                               scale:scale</span><br><span class="line">                        maxPixelSize:maxPixelSize];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^ &#123;</span><br><span class="line">                <span class="keyword">self</span>.listItem.downsampledMediaImage = <span class="keyword">self</span>.downsampledImage;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 在有很多图片 asset 的情况下，记得一定要使用 Asset Catalog，因为它早已经帮你管理好了缓存区的大小（还有很多其他的东西）。</p></blockquote><p>如果想在成为内存和图片的一等公民这个话题中得到更多的启发，记得一定要看 WWDC 18 中这些有含金量的会议：</p><p>· <a href="https://developer.apple.com/videos/play/wwdc2018/416/?time=1074" target="_blank" rel="noopener">深入了解 iOS 内存</a><br>· <a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="noopener">图像和图形的最佳实践</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你不知道的就是不知道。要知道作为码农，你走上的的是一个每天需要跑 10000 公里才能赶得上潮流的不归路。换句话说就是，有成千上万的你没接触过的 API，框架，模式或者优化方式。</p><p>这也适用在图片处理上。大部分时候你都会用一堆漂亮的像素点来初始化 UIImageView 就哦了。我理解，摩尔定律嘛，反正这些手机都有几个 G 的内存。况且，我们就用了那种不到 100k 内存的电脑就把人给送上了月球了。</p><p>但是俗话说得好，常在河边走哪有不湿鞋。不要让内存垃圾成为系统给你罚款的理由，因为现在随便一张自拍都得要一个 G 的内存。但愿这些知识和套路能减少你看崩溃日志的次数。</p><p>请听下回分解✌️。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Jordan Morgan，&lt;a href=&quot;https://www.swiftjectivec.com/optimizing-images/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：201
      
    
    </summary>
    
      <category term="翻译" scheme="http://cyberhex.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Swift" scheme="http://cyberhex.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Design Pattern" scheme="http://cyberhex.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 View Controller Containment</title>
    <link href="http://cyberhex.me/2019/06/21/viewcontroller-containment/"/>
    <id>http://cyberhex.me/2019/06/21/viewcontroller-containment/</id>
    <published>2019-06-21T13:59:24.781Z</published>
    <updated>2020-06-14T11:01:32.489Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在工作过程中如何利用 View Controller Containment 来重构 UI<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道你有没有经历过这样的情况，一个页面中有很多的 View，但各个 View 之间有明显的层级关系，这个时候一种可行的做法是把一系列相关联的 View 归到一个父亲 View 中。 但这种做法会有有一些其他的问题， 比如会让 View Controller 或者 View Model 比较大， 甚至有时候不得不把逻辑写在 View 里边。那么有没有一个既可以解决问题， 又不会引入更多棘手的问题的方法吗？ 问得好！ 如果你心里真的这个问题，那说明你一定是在质疑我写这篇分享的初衷。 不过别担心，看到最后我保证你一定会有所收获的。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>铺垫了这么多，你可能会想: View Controller Containment 到底是什么个玩意，从来没听说过，确定会有人用这个吗？ 但是接下来我会打消你的疑虑，因为苹果自己就在设计 UINavigationController 和 UITabBarController 利用了这种模式。在UINavigationController 和 UITabBarController 中你都可以塞入自定义的控制器， 只不过他们控制这些控制器的形式不同（一个是堆叠，一个是平行）。</p><p>那么 View Controller Containment 到底是什么呢？ 其实非常简单，就是把一个控制器当作容器，只不过这个控制器比较特别一点，它不止能控制 View， 还可以控制在它里边的控制器。 这种模式中，父控制器只需要来管理和安排子控制器 View 的布局和大小，而子控制器负责它自己内部各个 View 的布局和大小。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>听起来如此简单的改变，能给我们带来什么呢？这就需要讨论一下 View Controller Containment 的优点。</p><h3 id="可复用性"><a href="#可复用性" class="headerlink" title="可复用性"></a>可复用性</h3><p>利用 View Controller Containment 一个很大的优点就是可复用性，比如上边提到的苹果自带 SDK 中的 UINavigationController 和 UITabBarController 都有极大的可复用性，基本上在每个项目中都会用到。在项目中我们有时候也会碰到一些情况会有需要复用 Root View Controller 的情况。比如我在最近的一个项目中，会碰到有在同一个页面有三个区块，并且在项目不同的地方会对它们做相同的布局甚至动画。所以这种情况下抽出来一个可复用的 Root View Controller 就会极大的提高工作效率。</p><h3 id="逻辑分离"><a href="#逻辑分离" class="headerlink" title="逻辑分离"></a>逻辑分离</h3><p>对于一些比较复杂的页面，分出来不同的控制器，让子控制器来控制各自的逻辑，这样会让整个 UI 的结构更加清晰，每一个控制器的职责更加明确，会有更强的拓展性，以后如果想加入新的功能或者动画，我们只需要加入新的控制器，最多再加几个回调和代理，并不需要对原来的 UI 结构有很大的改动。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>拿我现在做的一个直播页边来举例，里边有比较明显的三个区块，一个课件区，一个视频区，一个是讨论区。每个区块上边还有一些相关的 View。 所以我觉得可以用 View Controller Containment 来实现。 用一个 MasterViewController 来管理这三个区域。 这三个区域也是不同的子控制器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoViewController</span>: <span class="title">UIViewController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeynoteViewController</span>: <span class="title">UIViewController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatViewController</span>: <span class="title">UIViewController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterViewControlller</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> videoViewController: <span class="type">VideoViewController</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">VideoViewController</span>()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> keynoteViewController: <span class="type">KeynoteViewController</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">KeynoteViewController</span>()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> chatViewController: <span class="type">ChatViewController</span> = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ChatViewController</span>()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - Add Child View Controllers</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupInterface</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        addChild(videoViewController)</span><br><span class="line">        addChild(keynoteViewController)</span><br><span class="line">        addChild(chatViewController)</span><br><span class="line"></span><br><span class="line">        view.addSubViews([</span><br><span class="line">            videoViewController.view,</span><br><span class="line">            keynoteViewController,</span><br><span class="line">            chatViewController</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里进行对子控制器的 View 的布局</span></span><br><span class="line"></span><br><span class="line">        videoViewController.didMove(toParent: <span class="keyword">self</span>)</span><br><span class="line">        keynoteViewController.didMove(toParent: <span class="keyword">self</span>)</span><br><span class="line">        chatViewController.didMove(toParent: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - Remove Child View Controller</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(asChild viewController: UIViewController)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Notify Child View Controller</span></span><br><span class="line">        viewController.willMove(toParent: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove Child View From Superview</span></span><br><span class="line">        viewController.view.removeFromSuperview()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notify Child View Controller</span></span><br><span class="line">        viewController.removeFromParentViewController()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的点是在做布局之前要使用 addChild(:) 方法，这样会触发子控制器的 willMove(toParent:) 方法，并且在布局完后要使用 didMove(toParent:) 方法。在移除 Child View Controller 的时候也需要重复相似的步骤，在移除 View 之前要使用 willMove(toParent:)， 在移除 View 之后使用 removeFromParentViewController() 方法。这样的做的好处是可以把子控制器的生命周期纳入父控制器的控制范围：在父控制器加入或者移除子控制器的时候能够触发子控制器的 viewWillAppear 和 viewWillDisappear 的方法。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>View Controller Containment 是一种非常实用的重构 UI 的设计模式，我在接触了这种模式后就开始欲罢不能（谁用谁知道）。这种模式不仅能增加代码的复用性和可拓展性，还可以将逻辑进行分离从而增加代码的可读性。所以把它加入你的 skill set 中会给你以后的工作和学习带来很大的益处。</p><div class="note info"><p>相关链接：</p><p><a href="https://cocoacasts.com/managing-view-controllers-with-container-view-controllers" target="_blank" rel="noopener">Managing View Controllers With Container View Controllers</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在工作过程中如何利用 View Controller Containment 来重构 UI&lt;br&gt;
    
    </summary>
    
      <category term="工作总结" scheme="http://cyberhex.me/categories/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Swift" scheme="http://cyberhex.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Design Pattern" scheme="http://cyberhex.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中的并发性问题</title>
    <link href="http://cyberhex.me/2018/11/27/concurrency-in-iOS/"/>
    <id>http://cyberhex.me/2018/11/27/concurrency-in-iOS/</id>
    <published>2018-11-27T05:39:41.000Z</published>
    <updated>2020-07-07T16:59:53.620Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在学习 iOS 的过程中关于并发性的问题。<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在开发过程中曾经遇到过挺多次并发的问题，比如在自己写 networking 代码的时候会遇到一些（对！我是自己手写 networking code， 老板禁止使用 Alamofire， 所以我就自己写了一个很小的库，以后有机会跟大家分享），但都是比较皮毛的东西，感觉自己并没有深入理解并发行的问题，现在下定决心好好研究一下并发性，毕竟面试会考挺多而且以后也会碰到很多。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在很多事情都是多线的，电脑是多核的，手机是双卡双待的，你看我，我可以一边写博客，一边玩LOL(呃，不知道为什么就抄袭了爱情公寓的台词，不过好像有点讽刺)。其实我是想说，由于现在手机是多核的，意味着同一时间手机可以同时处理多个问题，于是很多现代操作系统比如 iOS 和 OS10 就利用利用了这个特点而使用多线程。在这里我就想提出一个千古难题，进程和线程的区别是啥，说实话，到今天之前我对这两个概念还是比较模糊。进程的定义是正在执行程序的一个实体，线程定义是程序的执行路径。简而言之,在 iOS 系统中，进程可以理解为就是一个 App, 而线程是程序执行流的最小单元，一个进程至少有一个线程。其实我的理解也还没到完全的地步，大家可以参考<a href="https://juejin.im/post/5b1cf4fa6fb9a01e4b062771" target="_blank" rel="noopener">我所理解的 iOS 并发编程</a>和<a href="https://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="noopener">进程和线程的区别</a>。并发性有很多可以研究的问题，下面我想主要说一下 GCD 和 Operation Queue。</p><h2 id="Main-Queue-vs-Background-Queue"><a href="#Main-Queue-vs-Background-Queue" class="headerlink" title="Main Queue vs. Background Queue"></a>Main Queue vs. Background Queue</h2><p>在 iOS 中有两个重要的概念，Main Queue 和 Background Queue，这两个东西有什么用呢？ 试想一下，如果你每次打开抖音都会先白屏三秒钟才出现图片，那你还会这么没日没夜的刷它吗？ 如果出现这种情况，最有可能的情况只有两种：</p><ol><li>iPhone XS 在向你招手，扔掉手中的老手机，下一站，黑市交易所。</li><li>本来应该在 Background Queue 运行的 networking 奇瑞跑到了 Main Queue 的快车道上蹩住了你的校长牌阿斯顿 UI。</li></ol><p>一般情况下, 第二种情况发生的概率比较大。那么要怎么办呢？当然是利用你尊贵的身份改变交通规则，让开奇瑞的全部都去慢车道开，如果进入快车道，可以直接没收作案工具。这在现实生活中可能显得有点扯淡(?)。但是在 iOS 中不失为一种非常有效率的解决办法。 让运行较慢的 networking code 进入 Background Queue 运行，等到运行完成了再通知系统更新 UI。 这样就能大大提高用户体验，让用户刷抖音到天亮不是梦。</p><h2 id="Grand-Central-Dispatch-GCD"><a href="#Grand-Central-Dispatch-GCD" class="headerlink" title="Grand Central Dispatch(GCD)"></a>Grand Central Dispatch(GCD)</h2><p>先讲一点点历史， GCD 为什么要叫 Grand Central Dispatch 而不是 Large Central Dispatch 或者 Big Central Dispatch ? 这是由于在纽约有一个非常著名的地铁站叫 Grand Central Terminal，这个地方差不多是曼哈顿中一个地标型站点，后来程序员们在设计 GCD 的时候觉得在管理不同的线程的时候和 Grand Central Terminal 有异曲同工之妙，然后就堂而皇之的抄袭(程序猿的事能算抄吗）了这个名字。如果你是一个 iOS 开发员并且有幸去纽约玩的话一定要去膜拜一下这个有意义的站点。</p><p>GCD 作为苹果推荐的管理多线程的方式，肯定是有他的优势的，首先它的运行速度极快（每个 block 的运行速度是纳秒级别的）; 其次, GCD 的调用接口非常简单，只需要在最后的 closure 中写入要执行的代码就可以调用了，代码结构清晰，要做什么也显得一目了然，所以在网络请求和图片的异步加载中经常能看到它的身影。</p><p>GCD 中有两个核心的概念： 任务和队列</p><blockquote><p>任务</p></blockquote><p>GCD 中的任务就是加入到 closure 中的那一段代码，任务按照执行方式分为两种：</p><ol><li>同步执行的任务会阻塞当前线程，等待 closure 中的代码执行完成后当前线程才会继续。</li><li>异步执行的任务不会阻塞当前线程，当前线程会继续执行。</li></ol><blockquote><p>队列</p></blockquote><p>GCD 中队列指的是任务的等待队列，也就是在任务进入线程执行前排队的地方。队列遵循先进先出（FIFO）的原则，队列也分为两种：</p><ol><li>串行队列无法开启新的线程，所以线程中的任务会在当前线程一个一个执行，也就是说前一个任务执行完了下一个任务才会开始执行。这个就像在奶茶店门口买奶茶一样，只有上一个顾客买完了，下一个才可以买。</li><li>并行队列有开启新线程的能力，所以线程中的任务无需等待上一个任务完成就可以进入其他线程执行（但整个队列还是遵循先进先出的原则，只不过队列分发的特别快，看起来像一起执行）。这个就像在银行排队办理业务，因为有好多窗口，所以下一个人没必要等上一个人办理完业务才开始办理（除非窗口已全部被占用）。</li></ol><h3 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h3><p>在实际应用中，我们碰到的有三种常用队列：主队列，全局队列和自创队列。</p><p>首先我们先看自创队列：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="keyword">let</span> backgroundQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.cyberhex.concurrent.queue"</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure></p><p>上边就是创建队列的过程，DispatchQueue 的构造函数需要好多个参数，但是除了 label 其他的都是可选参数（如下），一般来说创建的队列都是并行队列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispathQueue 的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(label: <span class="type">String</span>, qos: <span class="type">DispatchQoS</span> = <span class="keyword">default</span>, attributes: <span class="type">DispatchQueue</span>.<span class="type">Attributes</span> = <span class="keyword">default</span>, autoreleaseFrequency: <span class="type">DispatchQueue</span>.<span class="type">AutoreleaseFrequency</span> = <span class="keyword">default</span>, target: <span class="type">DispatchQueue</span>? = <span class="keyword">default</span>)</span><br></pre></td></tr></table></figure><p>另外两个是可以直接调用无需创建，分别是主队列（Main Queue）和全局队列（Global Queue)。</p><p>其中主队列是串行队列，主要用于处理 UI 相关的任务，其他耗时的任务如网络请求或者下载图片需要另开线程进行处理，给 UI 大爷让路。</p><p>说到这个我想扯一个不是特别相关的，前一阵面试某条被问到了一个关于主队列的问题，具体是：为什么 UI 不能在主线程之外的线程运行，为什么系统会报错。说实话，我还真是没有了解过，面试完了以后查了资料才明白。</p><p>简单来说就是 UIKit 不是线程安全的，所以如果在其他线程更新 UI 会引起整个应用 UI 的混乱，具体为什么 UIKit 不是线程安全的等其他问题，大家可以看<a href="https://blog.csdn.net/qq_36557133/article/details/86531816" target="_blank" rel="noopener">这篇博客</a></p><p>回到正题，全剧队列是一个并行的队列，你可以把需要并行处理的任务交给它来处理。主队列和全局队列的获取如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispathQueue 的定义</span></span><br><span class="line"><span class="keyword">let</span> mainQueue = <span class="type">DispatchQueue</span>.main</span><br><span class="line"><span class="keyword">let</span> globalQueue = <span class="type">DispatchQueue</span>.global()</span><br></pre></td></tr></table></figure><p>GCD 就暂时先说到这里，我知道还有很多其他的东西比如信号量（Semaphore）和 DispatchWorkItem，这些以后有机会了再总结。</p><h2 id="Operation-和-Operation-Queue"><a href="#Operation-和-Operation-Queue" class="headerlink" title="Operation 和 Operation Queue"></a>Operation 和 Operation Queue</h2><p>Operation 是对于 GCD 的一个封装，相比于轻量级的 GCD，Operation 是完全面向对象的，它提供了多个接口可以实现暂停、继续、终止、优先顺序、依赖等复杂操作，比 GCD 更加灵活。在运行速度方面不如 GCD，是处于毫秒级别。</p><p>Operation 和 Operation Queue 对应与 GCD 的任务和队列，所以与之相对应的，它也有同步异步，串行并行之分，只不过表现形式不同。</p><h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>最后奉上我只在在某大厂笔试碰到的两道与GCD 和 Operation Queue 相关的题目。</p><ol><li>请写出下面代码执行顺序以及每次执行前等待了多长时间？并解释下原因？</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispathQueue 的定义</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                sleep(<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"1"</span>+<span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"2"</span> + <span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"3"</span> + <span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>如果把上面的DispatchQueue.main.async都改成DispatchQueue.global().async是怎么输出呢？并解释下原因？</p></li><li><p>如果下面这种情况请输出print输出顺序？并解释原因，如果maxConcurrentOperationCount = 1结果会是什么样子？</p></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispathQueue 的定义</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">OperationQueue</span>()</span><br><span class="line">        queue.maxConcurrentOperationCount = <span class="number">2</span></span><br><span class="line">        queue.addOperation &#123;</span><br><span class="line">            queue.addOperation &#123;</span><br><span class="line">                sleep(<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"1"</span>+<span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"2"</span>+<span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            queue.addOperation &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"3"</span>+<span class="string">"\(Thread.current)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>答案我会在下一篇博客中揭晓。</p><div class="note info"><p>相关链接：</p><p><a href="https://teamtreehouse.com/library/concurrency-in-ios" target="_blank" rel="noopener">Tree House: Concurrency in iOS</a><br><a href="http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html" target="_blank" rel="noopener">Linus Torvalds 的邮件</a><br><a href="https://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="noopener">进程和线程的区别</a><br><a href="https://juejin.im/post/5b1cf4fa6fb9a01e4b062771" target="_blank" rel="noopener">我所理解的 iOS 并发编程</a><br><a href="http://khanlou.com/2016/04/the-GCD-handbook/" target="_blank" rel="noopener">The GCD Handbook</a><br><a href="https://www.objc.io/issues/2-concurrency/" target="_blank" rel="noopener">OBJC Concurrent Programming</a><br><a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="noopener">iOS 多线程：『GCD』详尽总结</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在学习 iOS 的过程中关于并发性的问题。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://cyberhex.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://cyberhex.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Concurrency" scheme="http://cyberhex.me/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 中 Nullability 的使用</title>
    <link href="http://cyberhex.me/2018/11/25/nullability-annotations-in-objective-c/"/>
    <id>http://cyberhex.me/2018/11/25/nullability-annotations-in-objective-c/</id>
    <published>2018-11-25T14:23:19.000Z</published>
    <updated>2020-06-14T11:00:22.148Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录在学习 Objective-C 的过程中关于 Nullability 的问题。<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们都知道 Swift 和 Objective-C 可以同时存在于同一个 project 中，但想让他们俩兄弟同时幸福快乐和谐的生活在同一个项目中并不是一件容易的事。 Swift 小老弟最大的优势就是 Type Safety, 而 Objective-C 老大哥最大的“问题”就是可以有满屏的 nil。 在 Swift 中如果你想在不初始化一个变量的情况使用这个变量，你必须要提前告知 Xcode 这个变量是 optional 的， 但是 Objective-C 就没有这样的要求。 那么怎么解决这个问题呢，苹果最后引入了 Nullability 来给 Objective-C 加入一些安全保障。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>在 Objective-C 中有以下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *username;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *password;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)loginWithUsername:(<span class="built_in">NSString</span> *)username</span><br><span class="line">                 password:(<span class="built_in">NSString</span> *)password;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>但是如果这段代码是存在与两种语言混合的项目中，这段代码 import 进如 Swift 之后就成了一下这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">var</span> password: <span class="type">String</span>!</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(withUsername username: String!,</span></span></span><br><span class="line"><span class="function"><span class="params">                            password: String!)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了满屏的惊叹号，这对于有强迫症的同学简直是一种煎熬，为什么会这样呢？<br>因为 Swift 是 Type Safe 的语言，除非你提前申明这个变量是 optional，否则他不会让你随便给变量赋值 nil。</p><p>但是，如果在 Objective-C 中引入了 Nullability， 这个问题就会大大改善，比如下边的例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonnull</span>, <span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *username;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *password;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)loginWithUsername:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)username</span><br><span class="line">                 password:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)password;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 Swift 中，接口就会变成以下的情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> password: <span class="type">String</span>？</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(withUsername username: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                            password: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，虽然这样解决的 Swift 和 Objective-C 之间搭桥的问题，Objective-C 本身并没有发生改变，他还是该吃吃，该喝喝，runtime 的行为模式和以前没啥区别，毕竟嘛，那什么改不了那啥。但是经过这样的改变，compiler 会站出来在我们用错 API 的时候提出警告。</p><h2 id="四种-Nullability-标记"><a href="#四种-Nullability-标记" class="headerlink" title="四种 Nullability 标记"></a>四种 Nullability 标记</h2><table><thead><tr><th style="text-align:center">Pointers</th><th style="text-align:center">Properties</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">_Null_unspecified</td><td style="text-align:center">null_unspecified</td><td style="text-align:center">默认值，在搭桥到 Swift 后会成为 unwrapped optional</td></tr><tr><td style="text-align:center">_Nonnull</td><td style="text-align:center">nonnull</td><td style="text-align:center">在搭桥到 Swift 后变成正常变量声明</td></tr><tr><td style="text-align:center">_Nullable</td><td style="text-align:center">nullable</td><td style="text-align:center">在搭桥到 Swift 后变成 optional</td></tr><tr><td style="text-align:center">N/A</td><td style="text-align:center">null_resettable</td><td style="text-align:center">这种变量在读的时候不会是 nil， 但是可以重置为nil</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这算是我第一篇正儿八经的博客了，也算是学习笔记性质的记录博客，所以内容不一定是完全正确的，所以还希望各位大佬不吝赐教，大家一起学习。</p><div class="note info"><p>相关链接：</p><p><a href="https://teamtreehouse.com/library/nullability-annotations-in-objectivec" target="_blank" rel="noopener">Tree House: Nullability Annotations in Objective-C</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录在学习 Objective-C 的过程中关于 Nullability 的问题。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://cyberhex.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://cyberhex.me/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://cyberhex.me/tags/Objective-C/"/>
    
      <category term="Nullability" scheme="http://cyberhex.me/tags/Nullability/"/>
    
  </entry>
  
  <entry>
    <title>写在前面的话</title>
    <link href="http://cyberhex.me/2018/11/22/initial-post/"/>
    <id>http://cyberhex.me/2018/11/22/initial-post/</id>
    <published>2018-11-22T05:27:54.000Z</published>
    <updated>2019-03-17T12:17:34.609Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">梦里不知身是客，直把他乡作故乡。</blockquote><br><a id="more"></a></p><p>这可能是来美国这四年来我第一次静下心来想好好写点东西。现在的我，蜗居在一间租来的短租房里，在美国这个大农村里卖掉了可能是生活中最重要的必备品 - 车，考虑着自己怎么会沦落到这个地步。生活与生存、梦想与现实，对于我来说不是选择题，而更像是灰掉了一个选项的无奈。可能是时候回国寻找下一个人生目标了，就算有再多的不甘心。</p><h2 id="时空锥"><a href="#时空锥" class="headerlink" title="时空锥"></a>时空锥</h2><p>曾几何时，我的脑子里想着的都是相对论，康德哲学，甚至怎么样改变世界。不知从何时开始，我关心的事情完全变成了怎么样活下去。不管怎么说，在于生活的这场战争中，我是败得一派涂地。</p><p>我对相对论中的时空锥和因果律深信不疑，不知到在之前的哪个时空节点发生的事件或者是别人的时空锥的介入，让我的人生有了如此大的变化。但是这也许是命，也许是运，谁知道呢？</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>毕竟有很长时间已经没有写东西了，本来有好多想说的话，但手放在键盘的那一刻就全忘了，能写这么些东西可能已经是绞尽脑汁了。现在说说自己接下来几个月的计划吧。</p><ol><li>作为一个iOS Developer，我现在只会swift语言，而对于ojective-c只是知道一些皮毛，所以接下来的一段时间我要好好地学一下objective-c。</li><li>争取每学一些新的知识都把它们整理成学习笔记，这样不仅对我自己来说是一个很好的复习，对于未来可能大概也许来我博客的读者也会有很大帮助。</li><li>好好锻炼身体，可能有两三个月没有好好健身了，是时候在回国之前塑造一下新的形象。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然感觉自己很失败，但是危机并不是一个贬义词，危险与机会并存，就看自己怎么把握，说不定就走狗屎运咸鱼翻身了呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;梦里不知身是客，直把他乡作故乡。&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
      <category term="感悟" scheme="http://cyberhex.me/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="http://cyberhex.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
