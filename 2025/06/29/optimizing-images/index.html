
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>优化图片 - CyberHex</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="CyberHex, iOS, Swift, Development,"> 
    <meta name="description" content="Simple(r) Always Wins.,
作者：Jordan Morgan，原文链接，原文日期：2018-12-11译者：CyberHex；

人们常说你手里的相机就是最好的那个。如果俗语能说明一些问题的话，那么毫无疑问，iPhone 完,"> 
    <meta name="author" content="Penstein"> 
    <link rel="alternative" href="atom.xml" title="CyberHex" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

    
    <script>var musiclist = ""</script>
    
<script src="/js/loadaplayer.js"></script>

    <!-- 引用依赖 -->
    
<link rel="stylesheet" href="/aplayer/dist/APlayer.min.css">

    
<script src="/aplayer/dist/APlayer.min.js"></script>
<script src="/js/Meting.min.js"></script>

    
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">CyberHex</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://cyberhex.me">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">优化图片</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url('/img/cover.png') ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/翻译"><b>「
                    </b>翻译<b> 」</b></a>
                
                六月 29, 2025
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2025/06/29/optimizing-images/" title="优化图片" class="">优化图片</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>文章字数</i>
                    24k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>阅读约需</i>
                    22 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>阅读次数</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/Design-Pattern/" rel="tag">Design Pattern</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/Swift/" rel="tag">Swift</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <blockquote>
<p>作者：Jordan Morgan，<a target="_blank" rel="noopener" href="https://www.swiftjectivec.com/optimizing-images/">原文链接</a>，原文日期：2018-12-11<br>译者：CyberHex；</p>
</blockquote>
<p>人们常说你手里的相机就是最好的那个。如果俗语能说明一些问题的话，那么毫无疑问，iPhone 完全就是这个星球上最重要的相机。而且整个行业也证明了这件事。</p>
<p>出去度假了？不给你的 Instagram 上传几张照片顺便在手机里存几张备用的都不太可能。</p>
<p>又出了个大新闻？翻翻微博查看有关这个事件的图片就可以实时掌握有哪些渠道在播报这件事。</p>
<p>例子数不胜数。</p>
<p>但是尽管图片无处不在，想用一种既能保持高性能又不消耗很多内存的方式来展示这些图片还真得多费点劲。只要了解了 UIKit 中发生了什么，并且理解了它如何处理图片，我们就可以节省一大笔内存同时还能免去想砸键盘的冲动。</p>
<h2 id="讲一点理论"><a href="#讲一点理论" class="headerlink" title="讲一点理论"></a>讲一点理论</h2><p>先出一个脑筋急转弯：下面这张我女儿非常潮的照片有 266KB，猜一下它在 iOS 应用中需要占多少内存？</p>
<p><img src="https://www.swiftjectivec.com/assets/images/baylor.jpg" alt="Photo of dauther"></p>
<p>剧透警告：不是 266k，也不是 2.66M，而是 14M。</p>
<p>怎么会这样？</p>
<p>iOS 在得出内存使用的时候基于的是图片的维度，而图片真正的大小跟内存没有几毛钱关系。这张图片的维度是 1718 像素宽，2048像素高。假设每个像素占用四个字节内存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1718</span> <span class="operator">*</span> <span class="number">2048</span> <span class="operator">*</span> <span class="number">4</span> <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span> <span class="operator">=</span> 大约 <span class="number">13.42</span> <span class="type">MB</span></span><br></pre></td></tr></table></figure>

<p>假设你有一个包含一堆用户的 table view，每一行都在左上角用如今最流行的圆形来展示他们的头像。如果你觉得这没什么，因为这些图片已经用 ImageOptim 或者相似的东西压缩过了，那你就大错特错了。假设每个图片是 256x256 的话，这样还是会占掉不少的内存。</p>
<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>通过上边的例子，我们可以得出：了解渲染图片的机制也非常重要。当你载入一个图片，会有下边三个步骤：</p>
<p>1.载入：iOS 把压缩后的图片（在我们的例子中 266KB）放入内存中。这一步中并没有什么需要特别注意的。<br>2.解码：接下来，iOS 把图片转化为 GPU 可以理解和读取的形式。这一步中图片已经不是压缩状态了，现在就到了我们上边说的 14MB。<br>3.渲染：就像步骤名所说的一样，图片数据已经能够以任意形式被渲染到屏幕上，就算只是一个 60*60 那么小的 image view。</p>
<p>解码过程算一个比较重要的阶段。在这个过程中 iOS 会创建一个缓存区（准确的来说是一个图片缓存区），它是图片在内存中的表现形式。这就很好的解释了为啥这个缓冲区的大小本质上是和图片的面积而非文件大小挂钩的。从而也清楚的描绘了在计算图片的内存消耗时为什么图片的维度这么重要。</p>
<p>对于 UIImage 来说，当我们塞给他的不论是从网络请求或者是其他途径里得到的图片数据，它都会把这些数据缓存解析为数据中所要求的任何压缩形式（比如 PNG 或者 JPG）。但是，这些数据其实还是会继续存在，因为渲染不是一个只会进行一次的操作，所以 UIImage 会把图片缓存保存下来，确保它只被解析一次。</p>
<p>现在我们发散一下思维：一个可以适用于任何 iOS 应用的完整缓存区就是它的帧缓存区。当你的应用要出现在屏幕上时，帧缓存区把它真正的显示出来，因为缓存区里有需要被显示出来内容的渲染结果。任何 iOS 设备的显示硬件都可以利用这些像素信息把这些像素展现在屏幕上。</p>
<p>在这种情况下，时长就会影响结果。想得到 60 帧每秒的行云流水般的滑动，帧缓存区就需要让 UIKit 渲染应用的窗口，并且需要当子视图的信息有变化时（比如给 image view 添加图片），所有子视图都加到窗口上边。如果这一步完成的太慢的话，就会丢帧。</p>
<blockquote>
<p>你觉得六十分之一秒已经很短了？想象一下，有 Pro Motion 技术的设备会把这个数字提到一百二十分之一秒。</p>
</blockquote>
<h2 id="尺寸很重要"><a href="#尺寸很重要" class="headerlink" title="尺寸很重要"></a>尺寸很重要</h2><p>我们可以很容易的对这个过程和过程中的内存使用进行可视化。就用之前我女儿的那张照片，我创建了一个很简单的应用，里边有一个 image view 来展示这张照片：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url <span class="operator">=</span> <span class="type">NSURL</span>(fileURLWithPath: filePath)</span><br><span class="line"><span class="keyword">let</span> fileImage <span class="operator">=</span> <span class="type">UIImage</span>(contentsOfFile: filePath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image view</span></span><br><span class="line"><span class="keyword">let</span> imageView <span class="operator">=</span> <span class="type">UIImageView</span>(image: fileImage)</span><br><span class="line">imageView.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">imageView.contentMode <span class="operator">=</span> .scaleAspectFit</span><br><span class="line">imageView.widthAnchor.constraint(equalToConstant: <span class="number">300</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">imageView.heightAnchor.constraint(equalToConstant: <span class="number">400</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">view.addSubview(imageView)</span><br><span class="line">imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在实际工作中不要使用强行解包，这个例子比较简单，所以才小用一下。</p>
</blockquote>
<p>我们会得到如下结果：</p>
<p><img src="https://www.swiftjectivec.com/assets/images/baylorPhone.jpg" alt="Photo of dauther"></p>
<p>迅速去 LLDB 上瞄一眼就可以发现，就算我们用一个更小的 image view 来展示这张图，它的维度还是原来那样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="type">UIImage</span>: <span class="number">0x600003d41a40</span><span class="operator">&gt;</span>, &#123;<span class="number">1718</span>, <span class="number">2048</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意哟，这里可是用点来表示的。也就是说，如果我在用一个 3x 或者是 2x 的设备，有可能还会得到一个是这个倍数的数字。接下来我们转战去 vmmap，看我们能不能确认这张图用了 14MB 的内存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmmap <span class="operator">--</span>summary baylor.memgraph</span><br></pre></td></tr></table></figure>

<p>下边几项数据比较亮眼：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Physical</span> footprint:         <span class="number">69</span>.5M</span><br><span class="line"><span class="type">Physical</span> footprint (peak):  <span class="number">69</span>.7M</span><br></pre></td></tr></table></figure>

<p>现在有将近 70M 的内存使用，也给了我们一个重构代码的基准。如果我们集中再看看我们图片的内存消耗：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmmap <span class="operator">--</span>summary baylor.memgraph <span class="operator">|</span> grep <span class="string">&quot;Image IO&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">Image</span> <span class="type">IO</span>  <span class="number">13</span>.4M   <span class="number">13</span>.4M   <span class="number">13</span>.4M    0K  0K  0K   0K  <span class="number">2</span> </span><br></pre></td></tr></table></figure>

<p>啊嘞嘞，内存里有大约 14MB 的脏内存。这跟我们当时估算的图片的大小一样。为了充实论点，下边我给出了一张截图可以清晰的看出每一行的消耗，因为这是使用 grep 查到的。</p>
<p><img src="https://www.swiftjectivec.com/assets/images/vmmap.jpg" alt="Snapshot of grepin"></p>
<p>所以很明显，现在我们在一个 300 x 400 的 image view 上使用了原图所占的内存大小。图片的大小很重要，但是这不是唯一影响内存消耗的因素。</p>
<h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><p>你所请求使用的一部分内存是由另一个重要因素色域所决定的。在上边的例子中，我们做了一个在大部分 iPhone 中并不成立的假设，就是图片使用的是 sRGB 格式。一个像素点有4个字节是因为给了红、蓝、绿和透明度各一个字节。</p>
<p>如果你用一个支持非常广色域的手机（不如 iPhone 8P 或者 iPhone X）来拍照，你很有可能会使用双倍的内存。当然，倒过来也是对的。Metal 可以使用 Alpha 8 的格式，这种格式就跟它名字所暗示的那样，只用一个维度（透明度）。</p>
<p>这里边有好多需要考虑和操作的东西。这就是为什么我们要用 <a target="_blank" rel="noopener" href="https://www.swiftjectivec.com/uigraphicsimagerenderer/">UIGraphicsImageRender</a> 而不是用 UIGraphicsBeginImageContextWithOptions，后者总是会使用 sRGB，也就是说在你想用<a target="_blank" rel="noopener" href="https://instagram-engineering.com/bringing-wide-color-to-instagram-5a5481802d7d">更广的色域</a>的时候无法使用它们，或者在你想选择较小色域的时候没法节省内存。在 iOS 12 以后，UIGraphicsImageRender 会帮你选择最合适的那一个。</p>
<p>这里再提一嘴，免得过会再忘了，很多我们截的图片其实并不是拍摄类型，而仅仅是简单的绘图操作。并不是说想重提我前一阵写过的东西，但是以防你之前没看过：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> circleSize <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UIGraphicsBeginImageContextWithOptions</span>(circleSize, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画个圈圈</span></span><br><span class="line"><span class="keyword">let</span> ctx <span class="operator">=</span> <span class="type">UIGraphicsGetCurrentContext</span>()<span class="operator">!</span></span><br><span class="line"><span class="type">UIColor</span>.red.setFill()</span><br><span class="line">ctx.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">ctx.addEllipse(in: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line">ctx.drawPath(using: .fill)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circleImage <span class="operator">=</span> <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line"><span class="type">UIGraphicsEndImageContext</span>()</span><br></pre></td></tr></table></figure>

<p> 上边这个圆形图像使用的是每个像素 4 个字节的格式。如果使用 UIGraphicsImageRender 的话，它会自动帮你选择最合适的格式来渲染，这样你在全部选用每像素 1 个字节的格式的情况下最多能节省 75% 的内存。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> circleSize <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"><span class="keyword">let</span> renderer <span class="operator">=</span> <span class="type">UIGraphicsImageRenderer</span>(bounds: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circleImage <span class="operator">=</span> renderer.image&#123; ctx <span class="keyword">in</span></span><br><span class="line">    <span class="type">UIColor</span>.red.setFill()</span><br><span class="line">    ctx.cgContext.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">    ctx.cgContext.addEllipse(in: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: circleSize.width, height: circleSize.height))</span><br><span class="line">    ctx.cgContext.drawPath(using: .fill)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 

<h2 id="缩放-VS-降采样"><a href="#缩放-VS-降采样" class="headerlink" title="缩放 VS. 降采样"></a>缩放 VS. 降采样</h2><p>先把刚才那个简单的绘图的例子放在一边，其实大部分与图片相关会影响内存使用的问题都源自于那些现实生活中人们摄影的照片。包括用 portraits 和 landscape 拍出来的照片和一些其他的照片。</p>
<p>这也证明了为什么一些程序猿们会觉得用 UIImageView 进行图片缩放就够使了。但是 UIImageView 的问题一般不是因为上边所罗列出来的原因，而且根据苹果大神 Kyle Howarth 的说法，它性能不好是因为内部坐标的转换。</p>
<p>在这种情况下，UIImage 会影响效率的一个主要原因是它会按照我们之前在渲染管线中讨论过的那样把原始图片压缩进内存中。而在理想情况下，我们需要想个办法来减少图片缓存区的大小。</p>
<p>庆幸的是，只用被缩放后图片所消耗的内存来调整图片大小是有可能的，这也是为什么好多人会以为这个是在缩放图片时的默认行为。然而实际情况并不是这样。</p>
<p>我们现在尝试换成底层的 API 来进行缩放：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageSource <span class="operator">=</span> <span class="type">CGImageSourceCreateWithURL</span>(url, <span class="literal">nil</span>)<span class="operator">!</span></span><br><span class="line"><span class="keyword">let</span> options: [<span class="type">NSString</span>:<span class="keyword">Any</span>] <span class="operator">=</span> [kCGImageSourceThumbnailMaxPixelSize:<span class="number">400</span>,</span><br><span class="line">                            kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> scaledImage <span class="operator">=</span> <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options <span class="keyword">as</span> <span class="type">CFDictionary</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> imageView <span class="operator">=</span> <span class="type">UIImageView</span>(image: <span class="type">UIImage</span>(cgImage: scaledImage))</span><br><span class="line">    </span><br><span class="line">    imageView.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    imageView.contentMode <span class="operator">=</span> .scaleAspectFit</span><br><span class="line">    imageView.widthAnchor.constraint(equalToConstant: <span class="number">300</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    imageView.heightAnchor.constraint(equalToConstant: <span class="number">400</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    view.addSubview(imageView)</span><br><span class="line">    imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 

<p>我们会得到和以前一样的结果。但是这次，我们用的是听起来就有逼格的 CGImageSourceCreateThumbnailAtIndex() 而不是简单得把图片丢给 image view 来处理。又一次，我们这次优化是否有效的真相就藏在 vmmap 中（为了简便就做了四舍五入）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmmap <span class="operator">-</span>summary baylorOptimized.memgraph</span><br><span class="line"></span><br><span class="line"><span class="type">Physical</span> footprint:         <span class="number">56</span>.3M</span><br><span class="line"><span class="type">Physical</span> footprint (peak):  <span class="number">56</span>.7M</span><br></pre></td></tr></table></figure> 

<p>我们已经能看到省了不少内存。如果和之前的 69.5MB 相比，56.3MB 足足少了 13.2MB。这是一笔很大的节省，几乎相当于整张图片的消耗。</p>
<p>接下来，有很多选择能让你在不同的情况下去做尝试。在 WWDC 18的会议 219 “图像和图形的最好实践”中，苹果公司的工程师 Kyle Sluder 给我们展示了一个非常有趣的方法 - 使用 kCGImageSourceShouldCacheImmediately 标识位来控制解析过程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">downsampleImage</span>(<span class="params">at</span> <span class="params">URL</span>:<span class="type">NSURL</span>, <span class="params">maxSize</span>:<span class="type">Float</span>) -&gt; <span class="type">UIImage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> sourceOptions <span class="operator">=</span> [kCGImageSourceShouldCache:<span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> source <span class="operator">=</span> <span class="type">CGImageSourceCreateWithURL</span>(<span class="type">URL</span> <span class="keyword">as</span> <span class="type">CFURL</span>, sourceOptions)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> downsampleOptions <span class="operator">=</span> [kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">                            kCGImageSourceThumbnailMaxPixelSize:maxSize</span><br><span class="line">                            kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">                            kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">                            ] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> downsampledImage <span class="operator">=</span> <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(source, <span class="number">0</span>, downsampleOptions)<span class="operator">!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 

<p>在上边的函数中，Core Graphics 会在你想要缩略图的特定时刻才会进行解析。 注意要像我们之前的那两个例子中一样加入 kCGImageSourceCreateThumbnailMaxPixelSize 的变量，因为如果你不加的话，你得到的缩略图会和原图一样大。文档中这样说：</p>
<blockquote>
<p>“如果不指定像素大小上限的话，缩略图就会跟原图一样大，你肯定不想看到这样的结果”</p>
</blockquote>
<p>所以发生了什么？简单的说，就是我们通过在缩放阶段使用缩略图从而创建了一个比以前小很多的解析图片缓存区。现在回头想想我们的渲染管线，第一步（载入）中我们丢给 UIImage 一个只包含我们要展示的图片的图片缓存区，而不是传入相当于整个图片维度的缓存区让它去解析。</p>
<p>如果你想用一秒钟来读完这篇文章的话就记住一句话。有机会的话一定要用降采样而不是使用 UIImage 的缩放来处理图片。</p>
<h2 id="彩蛋时间"><a href="#彩蛋时间" class="headerlink" title="彩蛋时间"></a>彩蛋时间</h2><p>我个人喜欢把上边的方法和 iOS 11 以后引入的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uitableviewdatasourceprefetching?language=swift">prefetch API</a> 放在一起用。要记住，因为我们要在 table view 或者 collection view 显示 cell 之前解析图片，所以我们很容易不知不觉的就引入 CPU 峰值。</p>
<p>因为 iOS 非常擅长在有稳定电量需求的情况下管理电量使用，但是在这种情况下电量需求是断断续续的，所以是时候让我们自己写的队列来展示真正的技术了。这样做也会把解析过程放在背景线程中，一石二鸟啊。</p>
<p>捂上你的双眼，别被下边我的小项目里的 OC 的代码亮瞎了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用你自己写的队列而不是 global async 可以避免线程崩溃</span></span><br><span class="line">- (<span class="type">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView prefetchRowsAtIndexPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downsampledImage != <span class="literal">nil</span> || </span><br><span class="line">        <span class="keyword">self</span>.listItem.mediaAssetData == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSIndexPath</span> *mediaIndexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="number">0</span></span><br><span class="line">                                                     inSection:SECTION_MEDIA];</span><br><span class="line">    <span class="keyword">if</span> ([indexPaths containsObject:mediaIndexPath])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> scale = tableView.traitCollection.displayScale;</span><br><span class="line">        <span class="built_in">CGFloat</span> maxPixelSize = (tableView.width - SSSpacingJumboMargin) * scale;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.downsampleQueue, ^&#123;</span><br><span class="line">            <span class="comment">// Downsample</span></span><br><span class="line">            <span class="keyword">self</span>.downsampledImage = [<span class="built_in">UIImage</span> downsampledImageFromData:<span class="keyword">self</span>.listItem.mediaAssetData</span><br><span class="line">                               scale:scale</span><br><span class="line">                        maxPixelSize:maxPixelSize];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^ &#123;</span><br><span class="line">                <span class="keyword">self</span>.listItem.downsampledMediaImage = <span class="keyword">self</span>.downsampledImage;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 在有很多图片 asset 的情况下，记得一定要使用 Asset Catalog，因为它早已经帮你管理好了缓存区的大小（还有很多其他的东西）。</p>
</blockquote>
<p>如果想在成为内存和图片的一等公民这个话题中得到更多的启发，记得一定要看 WWDC 18 中这些有含金量的会议：</p>
<p>· <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/416/?time=1074">深入了解 iOS 内存</a><br>· <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/219/">图像和图形的最佳实践</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你不知道的就是不知道。要知道作为码农，你走上的的是一个每天需要跑 10000 公里才能赶得上潮流的不归路。换句话说就是，有成千上万的你没接触过的 API，框架，模式或者优化方式。</p>
<p>这也适用在图片处理上。大部分时候你都会用一堆漂亮的像素点来初始化 UIImageView 就哦了。我理解，摩尔定律嘛，反正这些手机都有几个 G 的内存。况且，我们就用了那种不到 100k 内存的电脑就把人给送上了月球了。</p>
<p>但是俗话说得好，常在河边走哪有不湿鞋。不要让内存垃圾成为系统给你罚款的理由，因为现在随便一张自拍都得要一个 G 的内存。但愿这些知识和套路能减少你看崩溃日志的次数。</p>
<p>请听下回分解✌️。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >留言</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/profile.jpg" height=300 width=300></img>
                    <p>Penstein</p>
                    <span>Simple(r) Always Wins.</span>
                    <dl>
                        
                            
                            
                            
                        
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">20 <p>文章</p></a></li>
                    <li><a href="/categories">6 <p>分类</p></a></li>
                    <li><a href="/tags">9 <p>标签</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>目录</h4>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E7%82%B9%E7%90%86%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">讲一点理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="toc-number">2.</span> <span class="toc-text">渲染管线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BA%E5%AF%B8%E5%BE%88%E9%87%8D%E8%A6%81"><span class="toc-number">3.</span> <span class="toc-text">尺寸很重要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%89%B2%E5%9F%9F"><span class="toc-number">4.</span> <span class="toc-text">色域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE-VS-%E9%99%8D%E9%87%87%E6%A0%B7"><span class="toc-number">5.</span> <span class="toc-text">缩放 VS. 降采样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A9%E8%9B%8B%E6%97%B6%E9%97%B4"><span class="toc-number">6.</span> <span class="toc-text">彩蛋时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2025
        <span class="gradient-text">
            Penstein
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.9.4" target="_blank" rel="noopener">v1.4.9.4</a></small>
        
        
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Simple(r) Always Wins.', 'Simple(r) Always Wins.'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




<!-- 引用依赖 -->
<script>document.write(aplayerconf)</script>




</html>
